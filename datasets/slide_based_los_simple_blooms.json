{
  "course_title": "Operating Systems and Networks",
  "course_code": "CS3.301",
  "metadata": {
    "source": "All lecture slide decks (text-only)",
    "folder": "/Users/lakshmiprajnapenmetsa/Desktop/iiith/research/irel/honors/dynamic-chunking-and-concept-mapping/raw-data/osn_lecs",
    "framework": "Bloom's Taxonomy",
    "model": "gpt-oss:20b-cloud",
    "num_pdfs_found": 25,
    "num_decks_summarized": 25,
    "per_deck_text_truncation_chars": 45000,
    "note": "Per-deck prompts may truncate very long extracted text, but every PDF contributes via per-deck summaries."
  },
  "extraction_report": [
    {
      "deck": "OSN_L01.pdf",
      "extracted_chars": 10059,
      "status": "summarized"
    },
    {
      "deck": "OSN_L02.pdf",
      "extracted_chars": 5474,
      "status": "summarized"
    },
    {
      "deck": "OSN_L03.pdf",
      "extracted_chars": 13324,
      "status": "summarized"
    },
    {
      "deck": "OSN_L04.pdf",
      "extracted_chars": 9910,
      "status": "summarized"
    },
    {
      "deck": "OSN_L05.pdf",
      "extracted_chars": 8930,
      "status": "summarized"
    },
    {
      "deck": "OSN_L06.pdf",
      "extracted_chars": 10774,
      "status": "summarized"
    },
    {
      "deck": "OSN_L07.pdf",
      "extracted_chars": 7832,
      "status": "summarized"
    },
    {
      "deck": "OSN_L08.pdf",
      "extracted_chars": 5554,
      "status": "summarized"
    },
    {
      "deck": "OSN_L09.pdf",
      "extracted_chars": 13821,
      "status": "summarized"
    },
    {
      "deck": "OSN_L10.pdf",
      "extracted_chars": 11824,
      "status": "summarized"
    },
    {
      "deck": "OSN_L11.pdf",
      "extracted_chars": 11282,
      "status": "summarized"
    },
    {
      "deck": "OSN_L12.pdf",
      "extracted_chars": 10542,
      "status": "summarized"
    },
    {
      "deck": "OSN_L13.pdf",
      "extracted_chars": 11592,
      "status": "summarized"
    },
    {
      "deck": "OSN_L14.pdf",
      "extracted_chars": 6345,
      "status": "summarized"
    },
    {
      "deck": "OSN_L15.pdf",
      "extracted_chars": 8878,
      "status": "summarized"
    },
    {
      "deck": "OSN_L16.pdf",
      "extracted_chars": 6799,
      "status": "summarized"
    },
    {
      "deck": "OSN_L17.pdf",
      "extracted_chars": 6209,
      "status": "summarized"
    },
    {
      "deck": "OSN_L18.pdf",
      "extracted_chars": 7122,
      "status": "summarized"
    },
    {
      "deck": "OSN_L19.pdf",
      "extracted_chars": 5699,
      "status": "summarized"
    },
    {
      "deck": "OSN_L20.pdf",
      "extracted_chars": 9810,
      "status": "summarized"
    },
    {
      "deck": "OSN_L21.pdf",
      "extracted_chars": 9782,
      "status": "summarized"
    },
    {
      "deck": "OSN_L22.pdf",
      "extracted_chars": 10477,
      "status": "summarized"
    },
    {
      "deck": "OSN_L23.pdf",
      "extracted_chars": 10985,
      "status": "summarized"
    },
    {
      "deck": "OSN_L24.pdf",
      "extracted_chars": 10107,
      "status": "summarized"
    },
    {
      "deck": "OSN_L25_revision.pdf",
      "extracted_chars": 13093,
      "status": "summarized"
    }
  ],
  "deck_summaries": [
    {
      "deck": "OSN_L01.pdf",
      "topics": [
        "Operating System fundamentals and history",
        "OS as middleware and abstraction",
        "Virtualization: process and memory management",
        "Concurrency and multitasking",
        "Persistence and file system architecture",
        "Networking fundamentals and protocol stack",
        "Sockets, DNS, and network programming"
      ],
      "key_concepts": [
        "Operating System definition and role",
        "Process abstraction and isolation",
        "Memory virtualization (paging, segmentation)",
        "CPU scheduling algorithms (round‑robin, priority, FIFO)",
        "Context switching and CPU time sharing",
        "Deadlock, starvation, and resource allocation",
        "File system organization (inodes, directories, metadata)",
        "I/O device management and drivers",
        "TCP/IP protocol stack and layered architecture",
        "Socket API for network communication",
        "Domain Name System (DNS) resolution",
        "Virtualization of hardware resources",
        "Concurrency primitives (threads, semaphores, mutexes)",
        "Persistence of data via non‑volatile storage",
        "Abstraction layers in OS design",
        "Resource management and scheduling policies",
        "Network topologies (LAN, WAN, PAN, MAN)",
        "Protocol terminology (subnet, host, router, switch)",
        "ARPA‑NET origins and internet evolution",
        "Security and isolation in OS design"
      ],
      "skills": [
        "Analyze and compare CPU scheduling algorithms",
        "Design and implement a simple virtual memory simulator",
        "Debug and resolve concurrency issues in multi‑threaded programs",
        "Implement basic file system operations (create, read, write, delete)",
        "Develop socket‑based client/server applications",
        "Evaluate OS performance trade‑offs (overhead vs. abstraction)",
        "Model and detect deadlock scenarios in resource allocation",
        "Explain the role of device drivers in I/O management",
        "Interpret network packet flows in the TCP/IP stack",
        "Apply abstraction principles to simplify system design",
        "Use command‑line tools to inspect process and memory usage",
        "Plan and document a small OS‑related project"
      ],
      "important_terms": [
        "OS",
        "Kernel",
        "Process",
        "Thread",
        "Virtual memory",
        "Paging",
        "Segmentation",
        "Scheduling",
        "Context switch",
        "Deadlock",
        "Starvation",
        "Semaphore",
        "Mutex",
        "I/O device",
        "Driver",
        "File system",
        "inode",
        "TCP/IP",
        "UDP",
        "Socket",
        "DNS",
        "ARPANET",
        "LAN",
        "WAN",
        "Subnet"
      ]
    },
    {
      "deck": "OSN_L02.pdf",
      "topics": [
        "Process Fundamentals",
        "Process Creation & Memory Layout",
        "Process States & Transitions",
        "CPU Virtualization & Scheduling",
        "Context Switching & PCB",
        "Hardware Prerequisites (Registers & Pipeline)",
        "OS Data Structures for Process Management",
        "Illustrative Example & Xv6 Process Structure"
      ],
      "key_concepts": [
        "Process (running program)",
        "Address space",
        "Instruction pointer / Program counter",
        "Stack pointer",
        "Heap",
        "File descriptors",
        "Process states (running, ready, blocked)",
        "Context switch",
        "CPU scheduler",
        "Process Control Block (PCB)",
        "Lazy loading",
        "Time slicing / CPU virtualization",
        "Pipeline stages (fetch, decode, execute)",
        "Superscalar execution",
        "Process creation steps",
        "Process list",
        "Process ID (PID)",
        "Memory image",
        "I/O blocking"
      ],
      "skills": [
        "Identify process states from execution traces",
        "Explain the steps of a context switch",
        "Design a simple CPU scheduling algorithm",
        "Analyze process blocking due to I/O",
        "Interpret fields of a PCB",
        "Understand CPU pipeline stages",
        "Explain lazy loading of program segments",
        "Compare single-core vs multi-core scheduling",
        "Map process creation steps to OS actions",
        "Evaluate the impact of time slice on throughput"
      ],
      "important_terms": [
        "Process",
        "Program",
        "Executable",
        "Process ID (PID)",
        "Process Control Block (PCB)",
        "Address space",
        "Instruction pointer (IP)",
        "Program counter (PC)",
        "Stack pointer (SP)",
        "Heap",
        "Stack",
        "File descriptor",
        "I/O",
        "Context switch",
        "CPU scheduler",
        "Time slice",
        "Lazy loading",
        "Pipeline",
        "Fetch",
        "Decode",
        "Execute",
        "Superscalar",
        "Virtualization",
        "Xv6",
        "Operating System"
      ]
    },
    {
      "deck": "OSN_L03.pdf",
      "topics": [
        "Process Management Basics",
        "System Call Interface and POSIX",
        "Process Creation and Execution",
        "Shell and Command Pipeline",
        "Privilege Separation and Limited Direct Execution",
        "System Call Mechanism (Trap & IDT)",
        "Interrupts, Timer, and Scheduler",
        "Context Switching and Process Switching"
      ],
      "key_concepts": [
        "system call",
        "fork",
        "exec",
        "wait",
        "exit",
        "init process",
        "shell",
        "user mode",
        "kernel mode",
        "privilege separation",
        "Limited Direct Execution (LDE)",
        "trap instruction",
        "Interrupt Descriptor Table (IDT)",
        "timer interrupt",
        "preemptive scheduling",
        "cooperative scheduling",
        "context switch",
        "process table",
        "process state",
        "zombie process",
        "orphan process",
        "reaping"
      ],
      "skills": [
        "implement fork/exec simulation",
        "analyze process states and transitions",
        "design a system call interface",
        "simulate context switching",
        "understand privilege separation and user/kernel modes",
        "implement timer interrupt and scheduler logic",
        "write a simple shell pipeline",
        "debug zombie and orphan processes",
        "interpret trap handling and return-from-trap",
        "evaluate cooperative vs preemptive scheduling"
      ],
      "important_terms": [
        "OS",
        "API",
        "system call",
        "fork",
        "exec",
        "wait",
        "exit",
        "init",
        "shell",
        "user mode",
        "kernel mode",
        "privilege",
        "LDE",
        "trap",
        "IDT",
        "interrupt",
        "timer interrupt",
        "context switch",
        "scheduler",
        "process table",
        "process state",
        "zombie",
        "orphan",
        "reaping",
        "POSIX",
        "syscall handler",
        "kernel stack",
        "user stack"
      ]
    },
    {
      "deck": "OSN_L04.pdf",
      "topics": [
        "Process Virtualisation & System Calls",
        "Trap & Return‑from‑Trap Mechanics",
        "Interrupts & Timer‑Based Context Switching",
        "Scheduler Design & Scheduling Policies",
        "Performance Metrics & Fairness in Scheduling"
      ],
      "key_concepts": [
        "Trap instruction",
        "Return‑from‑Trap",
        "User mode vs Kernel mode",
        "Interrupt vs Trap",
        "LDE (Limited Direct Execution) protocol",
        "Timer interrupt handler",
        "Context switch assembly routine",
        "Process Control Block (PCB)",
        "Scheduler",
        "First‑Come‑First‑Serve (FCFS)",
        "Shortest‑Job‑First (SJF)",
        "Shortest‑Time‑to‑Completion‑First (STCF)",
        "Convoy effect",
        "Jain’s fairness index",
        "Preemptive scheduling",
        "Non‑preemptive scheduling",
        "IDT (Interrupt Descriptor Table)",
        "Kernel stack",
        "User stack"
      ],
      "skills": [
        "Implement a context‑switch routine",
        "Design a timer interrupt handler",
        "Analyze and compare FCFS, SJF, STCF policies",
        "Compute turnaround and response times",
        "Evaluate fairness using Jain’s index",
        "Differentiate between trap and interrupt handling",
        "Simulate process lifecycle from boot to exit",
        "Apply preemptive vs non‑preemptive scheduling decisions"
      ],
      "important_terms": [
        "TRAP",
        "RETURN‑FROM‑TRAP",
        "IDT",
        "LDE",
        "Kernel Stack",
        "User Stack",
        "Timer Interrupt",
        "Context Switch",
        "Scheduler",
        "FCFS",
        "SJF",
        "STCF",
        "Convoy Effect",
        "Jain’s Fairness Index",
        "Preemptive",
        "Non‑preemptive",
        "Process Control Block",
        "Process List",
        "System Call",
        "Interrupt Vector",
        "Kernel Mode",
        "User Mode"
      ]
    },
    {
      "deck": "OSN_L05.pdf",
      "topics": [
        "Scheduling Policies Overview",
        "Round Robin Scheduling",
        "I/O Handling in Scheduling",
        "Shortest Time to Completion First (STCF)",
        "Priority and Multi‑Level Feedback Queue (MLFQ)",
        "MLFQ Challenges and Mitigations",
        "MLFQ Tuning Parameters",
        "Inter‑Process Communication Across Machines"
      ],
      "key_concepts": [
        "Round Robin (time slice, context switch overhead)",
        "I/O Blocking and Interrupts",
        "Shortest Time to Completion First (preemptive SJF)",
        "Priority Scheduling",
        "Multi‑Level Feedback Queue (MLFQ) hierarchy",
        "Priority Boost to prevent starvation",
        "Gaming the scheduler (releasing CPU early)",
        "Starvation and fairness trade‑offs",
        "Process states (ready, running, blocked)",
        "Time slice sizing",
        "Queue time slice differentiation",
        "Periodic priority boost interval",
        "Preemption rules in MLFQ",
        "Round Robin within same priority",
        "Process arrival and burst estimation",
        "I/O burst handling",
        "Context switch cost",
        "Interactive vs CPU‑bound job classification",
        "Scheduling fairness metrics"
      ],
      "skills": [
        "Analyze turnaround vs response time trade‑offs",
        "Design and implement a Round Robin scheduler",
        "Incorporate I/O blocking into a scheduler",
        "Apply STCF for CPU‑bound processes",
        "Implement a Multi‑Level Feedback Queue scheduler",
        "Tune MLFQ parameters (queues, slices, boost interval)",
        "Detect and mitigate starvation in scheduling",
        "Model process communication across networked machines",
        "Evaluate scheduler fairness and performance metrics"
      ],
      "important_terms": [
        "CPU burst",
        "I/O burst",
        "Time slice",
        "Context switch",
        "Priority",
        "Queue",
        "Preemption",
        "Starvation",
        "Priority boost",
        "MLFQ",
        "Round Robin",
        "SJF",
        "STCF",
        "Interrupt",
        "Ready queue",
        "Blocked queue",
        "Process state",
        "Scheduling algorithm",
        "Fairness",
        "Response time",
        "Turnaround time",
        "Interactive job",
        "CPU‑bound job"
      ]
    },
    {
      "deck": "OSN_L06.pdf",
      "topics": [
        "Network Components and Devices",
        "IP Addressing and Network Identification",
        "LAN/WAN/MAN/PAN Types",
        "Layered Networking Models (OSI & TCP/IP)",
        "Data Encapsulation and Decapsulation",
        "Transport Layer Protocols and Port Management",
        "Routing, Switching, and Forwarding",
        "Process Communication over Networks (Sockets)",
        "Network Interfaces and Drivers",
        "Network Protocol Stack Overview"
      ],
      "key_concepts": [
        "IP addressing (IPv4, subnetting)",
        "MAC addressing",
        "Layered architecture and abstraction",
        "Encapsulation/Decapsulation process",
        "TCP vs UDP characteristics",
        "Port numbers and process identification",
        "Routing tables and path selection",
        "Switching (MAC learning)",
        "Hub vs Bridge vs Switch vs Router distinctions",
        "Network layer packet forwarding",
        "Physical medium types",
        "Error detection/correction at Data Link layer",
        "Flow control and error correction at Transport layer",
        "Session establishment and termination",
        "Application protocols (HTTP, SMTP, DNS, RTP)",
        "Network interface drivers and interrupts",
        "Socket programming basics",
        "Gateway concept",
        "Network topology (star, bus, ring)"
      ],
      "skills": [
        "Explain function of network devices (hub, switch, router, bridge, repeater)",
        "Describe IP addressing and subnetting",
        "Identify responsibilities of each OSI layer",
        "Demonstrate encapsulation/decapsulation steps",
        "Implement basic TCP/UDP socket communication",
        "Configure IP addresses and default gateways",
        "Analyze routing table entries and path selection",
        "Debug socket communication errors",
        "Model network traffic using packet diagrams",
        "Compare OSI vs TCP/IP models",
        "Use network interface drivers to send/receive packets",
        "Interpret network protocol headers"
      ],
      "important_terms": [
        "IP address",
        "MAC address",
        "IPv4",
        "TCP",
        "UDP",
        "HTTP",
        "SMTP",
        "DNS",
        "ICMP",
        "Ethernet",
        "WiFi",
        "Hub",
        "Switch",
        "Bridge",
        "Router",
        "Repeater",
        "LAN",
        "WAN",
        "MAN",
        "PAN",
        "OSI model",
        "TCP/IP model",
        "Encapsulation",
        "Decapsulation",
        "Packet",
        "Frame",
        "Segment",
        "Port",
        "Socket",
        "NIC",
        "Routing table",
        "Gateway"
      ]
    },
    {
      "deck": "OSN_L07.pdf",
      "topics": [
        "Transport Layer Fundamentals",
        "Socket API and System Calls",
        "Port Numbers and Addressing",
        "Multiplexing & Demultiplexing",
        "TCP vs UDP: Reliability & Efficiency",
        "Flow Control, Congestion Control, and Overhead",
        "UDP Checksum and Error Detection",
        "Operating System Interaction and Context Switching"
      ],
      "key_concepts": [
        "Socket creation and file descriptor abstraction",
        "bind(), listen(), accept(), connect() system calls",
        "send() / recv() data transfer primitives",
        "close() terminates a socket",
        "16‑bit port numbers as process mailboxes",
        "Well‑known vs. Ephemeral port allocation",
        "4‑tuple (src IP, dst IP, src port, dst port) for TCP sockets",
        "2‑tuple (dst IP, dst port) for UDP sockets",
        "Multiplexing at the sender: adding transport headers",
        "Demultiplexing at the receiver: routing to correct socket",
        "TCP reliability: ACKs, retransmission, sequencing",
        "TCP flow control: sliding window, congestion avoidance",
        "UDP lightweight header and lack of reliability mechanisms",
        "UDP checksum calculation using pseudo‑header",
        "Context switch opportunity on blocking socket calls",
        "Connection establishment (3‑way handshake) in TCP",
        "Connection termination (4‑way handshake) in TCP",
        "Header sizes: TCP ~20+ bytes, UDP ~8 bytes",
        "Error detection via checksum in UDP",
        "Use cases for TCP (HTTP, FTP) vs UDP (DNS, VoIP)"
      ],
      "skills": [
        "Implement a TCP client/server using the socket API",
        "Implement a UDP client/server with checksum verification",
        "Analyze blocking system calls and predict context switches",
        "Design port allocation strategies for servers",
        "Compare and contrast TCP and UDP features in real applications",
        "Simulate TCP flow control and congestion control behavior",
        "Compute and validate UDP checksums manually",
        "Explain how multiplexing/demultiplexing works in the transport layer",
        "Identify well‑known ports for common protocols",
        "Debug socket programming errors related to binding and listening",
        "Model the 3‑way and 4‑way handshakes in TCP",
        "Assess the overhead impact of transport headers on throughput"
      ],
      "important_terms": [
        "TCP",
        "UDP",
        "Socket",
        "bind",
        "listen",
        "accept",
        "connect",
        "send",
        "recv",
        "close",
        "Port",
        "Well‑known port",
        "Ephemeral port",
        "4‑tuple",
        "2‑tuple",
        "Checksum",
        "Pseudo‑header",
        "Flow control",
        "Congestion control",
        "Context switch",
        "Blocking syscall",
        "Multiplexing",
        "Demultiplexing",
        "Segment",
        "Packet",
        "Frame",
        "IP",
        "HTTP",
        "FTP",
        "SSH",
        "SMTP",
        "DNS",
        "802.11",
        "Ethernet",
        "DSL",
        "SONET"
      ]
    },
    {
      "deck": "OSN_L08.pdf",
      "topics": [
        "TCP fundamentals",
        "TCP header structure",
        "Reliability and flow control",
        "Connection establishment and termination",
        "Memory virtualization",
        "Virtual address space",
        "MMU and address translation",
        "Process isolation"
      ],
      "key_concepts": [
        "Sequence number tracking",
        "Acknowledgement number tracking",
        "Sliding window mechanism",
        "Flow control via receive window",
        "Congestion control bits (C/E)",
        "Delayed ACK strategy",
        "Retransmission timeout calculation",
        "RTT estimation (SampleRTT, EstimatedRTT, DevRTT)",
        "3‑way handshake sequence",
        "FIN and RST termination",
        "Virtual memory abstraction",
        "Virtual address space layout",
        "MMU role in address translation",
        "Page table mapping",
        "Process memory isolation"
      ],
      "skills": [
        "Compute RTT and timeout intervals",
        "Implement sliding window protocol",
        "Simulate 3‑way handshake",
        "Analyze ACK and retransmission behavior",
        "Design flow control with dynamic window sizing",
        "Implement delayed ACK logic",
        "Create virtual memory mapping simulator",
        "Simulate MMU address translation",
        "Evaluate process isolation mechanisms",
        "Plan memory allocation strategies"
      ],
      "important_terms": [
        "TCP",
        "SYN",
        "ACK",
        "FIN",
        "RST",
        "Sequence number",
        "Acknowledgement number",
        "Window size",
        "Sliding window",
        "Flow control",
        "Congestion control",
        "Delayed ACK",
        "Retransmission timeout",
        "RTT",
        "SampleRTT",
        "EstimatedRTT",
        "DevRTT",
        "Timeout interval",
        "3‑way handshake",
        "Virtual memory",
        "Virtual address space",
        "MMU",
        "Address translation",
        "Page table",
        "Process isolation"
      ]
    },
    {
      "deck": "OSN_L09.pdf",
      "topics": [
        "Memory Allocation APIs",
        "Virtual Memory Goals",
        "Dynamic Relocation (Base/Bounds)",
        "Segmentation (Explicit/Implicit)",
        "Address Translation & MMU",
        "Memory Protection & Fault Handling",
        "Fragmentation & Compaction",
        "Process Context Switching",
        "Debugging & Tooling",
        "C Runtime Memory Management"
      ],
      "key_concepts": [
        "malloc/free semantics",
        "brk/sbrk system calls",
        "mmap for anonymous memory",
        "calloc zero‑init",
        "realloc resizing",
        "Base register for relocation",
        "Bounds register for protection",
        "Dynamic relocation at runtime",
        "Segment registers (base, size, direction)",
        "Explicit segment identification via bits",
        "Implicit segment identification via PC/SP",
        "Stack growth direction handling",
        "External fragmentation in physical memory",
        "Compaction by moving segments",
        "Code sharing via read‑only segments",
        "Protection bits for read/write/execute",
        "Segmentation fault exception",
        "Address translation hardware (MMU)",
        "Context‑switch saving/restoring registers"
      ],
      "skills": [
        "Implement a simple malloc/free simulator",
        "Analyze common malloc/free errors (leaks, double free)",
        "Design base/bounds translation algorithm",
        "Simulate segmentation translation with explicit bits",
        "Identify segmentation faults from stack/heap overrun",
        "Use valgrind to detect memory errors",
        "Manage external fragmentation via compaction",
        "Understand MMU register usage in OS",
        "Explain protection bits and code sharing",
        "Debug C programs with memory allocation bugs"
      ],
      "important_terms": [
        "malloc",
        "free",
        "calloc",
        "realloc",
        "brk",
        "sbrk",
        "mmap",
        "MMU",
        "Base register",
        "Bounds register",
        "Segment register",
        "Virtual address",
        "Physical address",
        "Address translation",
        "Dynamic relocation",
        "Segmentation fault",
        "External fragmentation",
        "Compaction",
        "Code sharing",
        "Protection bits",
        "Stack pointer",
        "Heap pointer",
        "Garbage collector",
        "Valgrind"
      ]
    },
    {
      "deck": "OSN_L10.pdf",
      "topics": [
        "Segmentation and its limitations",
        "External and internal fragmentation",
        "Paging and virtual memory fundamentals",
        "Page tables and page table entries",
        "Translation Lookaside Buffer (TLB)",
        "TLB miss handling and context switching",
        "Memory allocation algorithms (best‑fit, first‑fit, buddy)",
        "Address space identifiers and page sharing",
        "Locality of reference in paging",
        "Hardware support for memory protection"
      ],
      "key_concepts": [
        "Segmentation: variable‑size logical segments",
        "External fragmentation: holes between segments",
        "Internal fragmentation: wasted space within a fixed block",
        "Paging: fixed‑size pages and frames",
        "Virtual address space vs physical address space",
        "Page table: per‑process mapping of VPN to PFN",
        "Page table entry bits: valid, present, dirty, reference, protection",
        "Translation Lookaside Buffer (TLB) as a cache of recent translations",
        "TLB miss handling: hardware walk vs software trap",
        "Address space identifier (ASID) to avoid TLB flush on context switch",
        "Memory allocation algorithms: best‑fit, first‑fit, worst‑fit, buddy",
        "Page fault: exception when a page is not in memory",
        "Page replacement policies: LRU, FIFO, Clock",
        "Compaction: moving processes to reduce fragmentation",
        "Spatial and temporal locality in memory access patterns",
        "Protection bits: read/write/execute permissions",
        "Dirty bit: indicates modified pages",
        "Reference bit: indicates recent access",
        "Valid bit: indicates whether a PTE is in use",
        "Present bit: indicates page is loaded in physical memory"
      ],
      "skills": [
        "Analyze the trade‑offs between segmentation and paging",
        "Compute virtual to physical address translation using page tables",
        "Design and implement a simple page table data structure",
        "Simulate TLB lookup and miss handling",
        "Evaluate the impact of memory allocation algorithms on fragmentation",
        "Implement a page fault handler in an operating system",
        "Assess the effect of locality on TLB hit rates",
        "Optimize context switch overhead by using ASIDs",
        "Create a memory compaction routine to reduce external fragmentation",
        "Compare different page replacement policies",
        "Demonstrate how page sharing reduces physical frame usage",
        "Write code to set and check protection bits for pages"
      ],
      "important_terms": [
        "Segmentation",
        "Paging",
        "Virtual Address",
        "Physical Address",
        "Page Table",
        "Page Table Entry",
        "VPN",
        "PFN",
        "Offset",
        "TLB",
        "ASID",
        "Page Fault",
        "Page Frame",
        "Page Size",
        "External Fragmentation",
        "Internal Fragmentation",
        "Compaction",
        "Best‑Fit",
        "First‑Fit",
        "Buddy Algorithm",
        "Protection Bits",
        "Dirty Bit",
        "Reference Bit",
        "Valid Bit",
        "Present Bit"
      ]
    },
    {
      "deck": "OSN_L11.pdf",
      "topics": [
        "Memory Virtualization & Paging",
        "TLB Architecture and Miss Handling",
        "Context Switching and ASID",
        "Page Table Size and Page Size Trade‑offs",
        "Hybrid Paging & Segmentation",
        "Multi‑Level Page Tables",
        "Inverted Page Tables",
        "Address Translation Flow"
      ],
      "key_concepts": [
        "TLB miss handling (hardware vs software)",
        "Address Space Identifier (ASID) for TLB entries",
        "Page Table Entry (PTE) fields (PFN, valid, protection)",
        "Page Directory and Page Directory Base Register (PDBR)",
        "Multi‑level page table construction and lookup",
        "Hybrid paging‑segmentation using base/bound registers",
        "Page size impact on internal fragmentation and table size",
        "Context switch effects on TLB and ASID handling",
        "TLB hit/miss patterns and hit rate calculation",
        "Page table allocation strategy (on‑demand page table pages)",
        "Inverted page table concept and search cost",
        "Page fault handling and swap space usage",
        "Offset calculation from virtual address",
        "Virtual to physical address translation steps",
        "Page frame allocation and mapping",
        "Memory Management Unit (MMU) role",
        "Page table walk during TLB miss",
        "Page directory entries and page table pages",
        "Page table entry replacement policies",
        "Page table size calculation for given address space"
      ],
      "skills": [
        "Analyze TLB hit/miss patterns and compute hit rates",
        "Calculate page table size for different page sizes",
        "Design and implement a multi‑level page table structure",
        "Implement a TLB miss handler for both hardware and software scenarios",
        "Evaluate page size trade‑offs on fragmentation and memory usage",
        "Simulate address translation from virtual to physical address",
        "Explain ASID usage in context switches",
        "Compare paging, segmentation, and hybrid approaches",
        "Assess the impact of context switches on TLB contents",
        "Design a hybrid paging‑segmentation system for a process",
        "Analyze inverted page table lookup costs",
        "Implement a simple page fault handler that uses swap space"
      ],
      "important_terms": [
        "TLB",
        "ASID",
        "VPN",
        "PFN",
        "PTE",
        "Page Directory",
        "Page Directory Base Register (PDBR)",
        "Page Table Base Register (PTBR)",
        "Page Frame",
        "Page Size",
        "Offset",
        "Virtual Address",
        "Physical Address",
        "Page Fault",
        "Context Switch",
        "Memory Management Unit (MMU)",
        "Swap Space",
        "Linear Page Table",
        "Multi‑Level Page Table",
        "Inverted Page Table",
        "Segmentation",
        "Page Table Walk",
        "Page Table Entry Replacement Policy"
      ]
    },
    {
      "deck": "OSN_L12.pdf",
      "topics": [
        "Virtual Memory Fundamentals",
        "Paging and Address Translation",
        "Swap Space and Page Faults",
        "Page Table Structures and Bits",
        "Page Replacement Algorithms",
        "Thrashing and Admission Control"
      ],
      "key_concepts": [
        "Virtual memory and paging",
        "Multi‑level page tables",
        "Translation Lookaside Buffer (TLB)",
        "Page table entry (PTE) fields: present, accessed, dirty",
        "Swap space management",
        "Page fault handling and context switches",
        "Optimal (MIN) replacement policy",
        "FIFO replacement policy",
        "Random replacement policy",
        "Least Recently Used (LRU) and Clock algorithm",
        "Belady’s anomaly",
        "Thrashing and admission control",
        "Average Memory Access Time (AMAT)",
        "Cold‑start (compulsory) misses",
        "Demand paging",
        "Memory hierarchy levels",
        "Page size, VPN, offset",
        "Physical frame number (PFN)",
        "Page replacement metrics"
      ],
      "skills": [
        "Design and explain a virtual memory system",
        "Simulate page fault handling and disk I/O",
        "Implement and analyze FIFO, LRU, Random, and Optimal replacement policies",
        "Use accessed and dirty bits to approximate LRU",
        "Compute AMAT for given hit/miss ratios",
        "Identify and mitigate thrashing scenarios",
        "Apply admission control to limit memory usage",
        "Interpret page table entries and TLB behavior",
        "Explain the role of swap space in demand paging",
        "Demonstrate Belady’s anomaly with example traces"
      ],
      "important_terms": [
        "Virtual address",
        "Physical address",
        "Page frame number (PFN)",
        "Page table entry (PTE)",
        "Present bit",
        "Accessed bit",
        "Dirty bit",
        "Swap space",
        "Disk I/O",
        "Page fault",
        "Translation Lookaside Buffer (TLB)",
        "Multi‑level page tables",
        "Demand paging",
        "Average Memory Access Time (AMAT)",
        "Cold‑start miss",
        "Compulsory miss",
        "FIFO",
        "Random",
        "Optimal (MIN)",
        "Least Recently Used (LRU)",
        "Clock algorithm",
        "Belady’s anomaly",
        "Thrashing",
        "Admission control",
        "Memory hierarchy"
      ]
    },
    {
      "deck": "OSN_L13.pdf",
      "topics": [
        "Application Layer Protocols",
        "HTTP Fundamentals and Extensions",
        "Web Caching and Content Distribution Networks",
        "Domain Name System (DNS) Architecture",
        "Network Application Architectures (Client‑Server & P2P)"
      ],
      "key_concepts": [
        "HTTP request/response format and methods (GET, POST, etc.)",
        "Persistent vs. non‑persistent HTTP connections",
        "HTTP status codes and semantics",
        "Cookies for session state management",
        "Web caching mechanisms and proxy servers",
        "Conditional GET and cache validation (If‑Modified‑Since, Last‑Modified)",
        "Content Distribution Network (CDN) placement strategies (Deep vs. Bring‑Home)",
        "DNS hierarchical resolution and recursive queries",
        "DNS resource record types (A, CNAME, NS, MX)",
        "DNS caching and TTL handling",
        "Statelessness of HTTP and stateful extensions",
        "HTTP/2 multiplexing, header compression, server push",
        "HTTP/3 (QUIC) transport layer changes",
        "Client‑Server vs. Peer‑to‑Peer application models",
        "Socket interface and application‑layer abstraction",
        "Transport layer protocols (TCP/UDP) in application context",
        "Domain name to IP address mapping",
        "Load distribution via DNS and CDN",
        "Session persistence using cookies"
      ],
      "skills": [
        "Implement a basic HTTP client and server handling GET/POST",
        "Design and test a simple web cache with conditional GET support",
        "Analyze performance impact of persistent vs. non‑persistent connections",
        "Configure and evaluate a CDN deployment strategy",
        "Resolve domain names using recursive DNS queries",
        "Create and interpret DNS resource records",
        "Simulate cookie storage and retrieval in a browser",
        "Explain statelessness and implement a stateful session mechanism",
        "Compare HTTP/1.1, HTTP/2, and HTTP/3 features",
        "Model client‑server and P2P application architectures",
        "Measure end‑to‑end latency with and without caching",
        "Apply TTL values to cache entries"
      ],
      "important_terms": [
        "HTTP",
        "TCP",
        "UDP",
        "DNS",
        "A record",
        "CNAME record",
        "NS record",
        "MX record",
        "TTL",
        "Cookie",
        "Web cache",
        "Proxy server",
        "CDN",
        "Persistent connection",
        "Non‑persistent connection",
        "HTTP/1.1",
        "HTTP/2",
        "HTTP/3",
        "Conditional GET",
        "If‑Modified‑Since",
        "Last‑Modified",
        "Stateless",
        "Stateful",
        "Session",
        "Socket",
        "Request line",
        "Response line",
        "Status code",
        "Header",
        "Body",
        "GET",
        "POST",
        "PUT",
        "HEAD",
        "DELETE"
      ]
    },
    {
      "deck": "OSN_L14.pdf",
      "topics": [
        "Process fundamentals recap",
        "Multi-threading basics",
        "Process vs Thread memory model",
        "Thread creation and scheduling",
        "Concurrency vs Parallelism",
        "Thread synchronization and race conditions",
        "POSIX threads API",
        "Kernel vs User threads"
      ],
      "key_concepts": [
        "Process",
        "Thread",
        "Program Counter (PC)",
        "Stack Pointer (SP)",
        "Address Space",
        "Page Table",
        "Copy‑on‑Write (CoW)",
        "Fork",
        "Exec",
        "Thread Control Block (TCB)",
        "Kernel Thread",
        "User Thread",
        "POSIX pthreads",
        "Thread scheduling",
        "Context switch",
        "Concurrency",
        "Parallelism",
        "Race condition",
        "Non‑determinism"
      ],
      "skills": [
        "Explain memory sharing between processes and threads",
        "Implement thread creation with pthread_create",
        "Schedule and context‑switch threads",
        "Identify and analyze race conditions in shared data",
        "Differentiate fork and exec semantics",
        "Distinguish concurrency from parallelism",
        "Describe kernel vs user thread models",
        "Debug non‑deterministic thread interleavings"
      ],
      "important_terms": [
        "OS",
        "Process",
        "Thread",
        "PC",
        "SP",
        "Address Space",
        "Page Table",
        "Copy‑on‑Write",
        "Fork",
        "Exec",
        "TCB",
        "Kernel Thread",
        "User Thread",
        "POSIX",
        "pthread_create",
        "Scheduling",
        "Context Switch",
        "Concurrency",
        "Parallelism",
        "Race Condition",
        "Non‑Determinism",
        "Synchronization",
        "Mutex",
        "Semaphore"
      ]
    },
    {
      "deck": "OSN_L15.pdf",
      "topics": [
        "Race Conditions & Critical Sections",
        "Mutual Exclusion & Atomicity",
        "Software Locks & Spin Locks",
        "Hardware Synchronization Primitives",
        "Test‑and‑Set & Compare‑and‑Swap",
        "Load‑Linked/Store‑Conditional",
        "Fetch‑and‑Add & Ticket Locks",
        "Fairness, Performance, and Starvation"
      ],
      "key_concepts": [
        "race condition",
        "critical section",
        "mutual exclusion",
        "atomicity",
        "lock/unlock",
        "test‑and‑set",
        "compare‑and‑swap",
        "load‑linked",
        "store‑conditional",
        "fetch‑and‑add",
        "ticket lock",
        "spin lock"
      ],
      "skills": [
        "identify race conditions",
        "design critical sections",
        "implement spin locks",
        "use test‑and‑set",
        "use compare‑and‑swap",
        "use load‑linked/store‑conditional",
        "build ticket locks",
        "evaluate lock fairness",
        "analyze performance overhead",
        "debug concurrency bugs"
      ],
      "important_terms": [
        "race condition",
        "critical section",
        "mutual exclusion",
        "atomicity",
        "lock",
        "unlock",
        "test‑and‑set",
        "compare‑and‑swap",
        "load‑linked",
        "store‑conditional",
        "fetch‑and‑add",
        "ticket lock",
        "spin lock",
        "starvation",
        "fairness",
        "interrupt masking"
      ]
    },
    {
      "deck": "OSN_L16.pdf",
      "topics": [
        "Concurrency primitives",
        "Spin and ticket locks",
        "OS scheduling primitives (yield, park/unpark)",
        "Condition variables and thread synchronization",
        "Producer‑Consumer / Bounded buffer problem",
        "Semaphores and Dijkstra’s solutions"
      ],
      "key_concepts": [
        "Ticket lock implementation using fetch‑and‑add",
        "Spin lock inefficiency and CPU waste",
        "OS yield syscall for cooperative yielding",
        "park()/unpark() for sleeping threads",
        "Condition variable wait() and signal() semantics",
        "Parent/child join using condition variables",
        "Race conditions in join/exit without locks",
        "Producer‑Consumer with single and multiple buffers",
        "Two condition variables for empty/full states",
        "Semaphore as a unified lock and counter",
        "Atomic fetch‑and‑add primitive",
        "Critical section protection",
        "Thread state transitions (running → ready → sleeping)",
        "Buffer indexing with fill/use counters",
        "Producer/consumer signaling patterns",
        "Deadlock avoidance via proper signaling",
        "Dijkstra’s semaphore concept",
        "Bounded buffer implementation details"
      ],
      "skills": [
        "Implement a ticket lock using fetch‑and‑add",
        "Analyze and mitigate spin lock CPU waste",
        "Use yield, park, and unpark to manage thread scheduling",
        "Design and implement condition variable wait/signal logic",
        "Create a robust join operation for parent/child threads",
        "Solve the producer‑consumer problem with condition variables",
        "Apply semaphore mechanisms to synchronize producers and consumers",
        "Identify and resolve race conditions in concurrent code",
        "Evaluate performance trade‑offs between spin locks and OS primitives",
        "Implement bounded buffer with multiple producers/consumers"
      ],
      "important_terms": [
        "ticket lock",
        "fetch‑and‑add",
        "spin lock",
        "yield syscall",
        "park syscall",
        "unpark syscall",
        "condition variable",
        "pthread_cond_t",
        "wait()",
        "signal()",
        "join()",
        "semaphore",
        "Dijkstra semaphore",
        "critical section",
        "atomic operation",
        "buffer full",
        "buffer empty",
        "producer‑consumer",
        "bounded buffer",
        "race condition",
        "deadlock",
        "mutex",
        "flag",
        "turn"
      ]
    },
    {
      "deck": "OSN_L17.pdf",
      "topics": [
        "Concurrency Fundamentals",
        "Producer–Consumer Problem",
        "Semaphores and Condition Variables",
        "Binary vs Counting Semaphores",
        "Deadlock and Starvation",
        "Readers–Writers Problem",
        "Priority and Fairness in Synchronization",
        "Implementation Patterns for Shared Buffers"
      ],
      "key_concepts": [
        "Producer–Consumer (bounded buffer)",
        "Condition Variable (wait/signal)",
        "Binary Semaphore as Mutex",
        "Counting Semaphore for resource counting",
        "sem_wait()/sem_post() semantics",
        "Negative semaphore value = waiting threads",
        "Mutex lock for critical section",
        "Deadlock detection and avoidance",
        "Starvation in Readers–Writers",
        "Readers–Writers with priority lock",
        "Semaphore as condition variable",
        "Buffer indexing (fill/use pointers)",
        "POSIX semaphore API",
        "Dijkstra’s P/V operations",
        "Wait queue ordering",
        "Priority scheduling for writers",
        "Signal waking strategy",
        "Atomic decrement/increment",
        "Critical section protection"
      ],
      "skills": [
        "Implement producer–consumer using semaphores",
        "Use binary semaphore as a lock",
        "Apply semaphores as condition variables",
        "Identify and resolve deadlock scenarios",
        "Analyze starvation in readers–writers",
        "Design priority‑based readers–writers solution",
        "Apply condition variables for thread signaling",
        "Understand semaphore wait/post semantics",
        "Implement multi‑producer/consumer buffer",
        "Evaluate synchronization primitive trade‑offs"
      ],
      "important_terms": [
        "semaphore",
        "sem_wait",
        "sem_post",
        "binary semaphore",
        "counting semaphore",
        "mutex",
        "condition variable",
        "producer",
        "consumer",
        "bounded buffer",
        "deadlock",
        "starvation",
        "readers",
        "writers",
        "priority lock",
        "wait queue",
        "critical section",
        "mutual exclusion",
        "signal",
        "P/V",
        "Dijkstra",
        "POSIX",
        "buffer index",
        "MAX",
        "empty",
        "full"
      ]
    },
    {
      "deck": "OSN_L18.pdf",
      "topics": [
        "Readers–Writers Concurrency Problem",
        "Dining Philosophers Problem",
        "Concurrency Bug Taxonomy",
        "Atomicity and Order Violations",
        "Deadlock Theory and Conditions",
        "Deadlock Prevention Techniques",
        "Deadlock Avoidance and Detection",
        "Synchronization Primitives (Semaphore, Mutex, CV)",
        "Hardware Atomic Operations (CAS)",
        "Lock Ordering and Trylock Strategies"
      ],
      "key_concepts": [
        "Readers–writers lock with priority queue",
        "Turnstile semaphore for service ordering",
        "Dining philosophers solution via asymmetric fork acquisition",
        "Atomicity violation caused by unsynchronized shared updates",
        "Order violation due to missing synchronization",
        "Four necessary conditions for deadlock (mutual exclusion, hold‑and‑wait, no preemption, circular wait)",
        "Lock ordering to eliminate circular wait",
        "Trylock (pthread_mutex_trylock) to avoid livelock",
        "Compare‑and‑Swap (CAS) for lock‑free updates",
        "Deadlock avoidance via scheduling (e.g., Banker's algorithm)",
        "Deadlock detection using resource‑allocation graphs",
        "Recovery by restarting or aborting transactions"
      ],
      "skills": [
        "Analyze and classify concurrency bugs in multithreaded code",
        "Design a readers–writers solution that prevents writer starvation",
        "Implement the dining philosophers problem with deadlock‑free strategy",
        "Apply semaphores, mutexes, and condition variables to synchronize threads",
        "Use lock ordering to avoid deadlock in complex systems",
        "Employ trylock and backoff to prevent livelock",
        "Utilize atomic primitives like CAS for lock‑free data structures",
        "Detect and recover from deadlocks using resource graphs",
        "Schedule thread execution to avoid resource contention",
        "Explain the trade‑offs between deadlock prevention, avoidance, and detection"
      ],
      "important_terms": [
        "Semaphore",
        "Mutex",
        "Condition Variable",
        "Atomicity",
        "Order Violation",
        "Deadlock",
        "Livelock",
        "Mutual Exclusion",
        "Hold‑and‑Wait",
        "No Preemption",
        "Circular Wait",
        "Lock Ordering",
        "Trylock",
        "Compare‑and‑Swap (CAS)",
        "Resource Allocation Graph",
        "Banker’s Algorithm",
        "Deadlock Detection",
        "Deadlock Avoidance",
        "Priority Queue",
        "Turnstile",
        "Readers–Writers Problem",
        "Dining Philosophers Problem"
      ]
    },
    {
      "deck": "OSN_L19.pdf",
      "topics": [
        "Link Layer Fundamentals",
        "MAC Addressing",
        "ARP Protocol and Cache",
        "Subnetting and CIDR",
        "Host-to-Host Communication Flow",
        "Encapsulation Hierarchy",
        "Network Layer Role",
        "Broadcast vs Unicast",
        "Default Gateway Functionality"
      ],
      "key_concepts": [
        "Link layer transfers datagrams hop‑to‑hop",
        "MAC address is 48‑bit IEEE‑assigned unique ID",
        "ARP resolves IP to MAC via broadcast request/reply",
        "ARP cache entries have TTL (≈20 min)",
        "Broadcast MAC FF:FF:FF:FF:FF:FF used for ARP queries",
        "Subnet mask defines network vs host bits (CIDR /24, /16)",
        "Default gateway IP used when destination is remote",
        "Encapsulation: Application → Transport → Network → Data Link → Physical",
        "Layer‑2 frames carry Ethernet header (MAC) and payload",
        "Layer‑3 packets carry IP header and payload",
        "ARP tables store <IP, MAC, TTL> mappings",
        "ARP request includes sender IP/MAC and target IP",
        "ARP reply is unicast to requester",
        "Switches forward frames based on MAC, routers forward packets based on IP"
      ],
      "skills": [
        "Explain responsibilities of the link layer",
        "Describe MAC address format and vendor prefix",
        "Analyze ARP request/reply packet flow",
        "Compute subnet mask and determine network membership",
        "Determine if a destination IP is local or requires gateway",
        "Configure and interpret ARP cache entries",
        "Explain encapsulation across OSI layers",
        "Differentiate broadcast and unicast traffic",
        "Identify default gateway usage in routing",
        "Troubleshoot ARP resolution failures"
      ],
      "important_terms": [
        "MAC address",
        "IP address",
        "ARP",
        "ARP cache",
        "ARP request",
        "ARP reply",
        "Broadcast address",
        "Subnet mask",
        "CIDR",
        "Default gateway",
        "Host",
        "Switch",
        "Router",
        "Frame",
        "Packet",
        "Encapsulation",
        "TTL",
        "IEEE",
        "Ethernet",
        "Layer 2",
        "Layer 3",
        "Network interface",
        "ARP table"
      ]
    },
    {
      "deck": "OSN_L20.pdf",
      "topics": [
        "Network Layer Functions and Encapsulation",
        "Subnetting and CIDR Notation",
        "ARP and Link‑Layer Interaction",
        "Routing Fundamentals: Forwarding and Routing Tables",
        "Static vs Dynamic Routing Protocols (OSPF, RIP, EIGRP)",
        "BGP and Inter‑AS Routing",
        "DHCP Process and IP Address Allocation",
        "IP Address Allocation and NAT",
        "NAT Types and Translation Tables",
        "Data Plane vs Control Plane in Routing"
      ],
      "key_concepts": [
        "Encapsulation hierarchy from Application to Physical layers",
        "Subnet mask calculation and CIDR notation (/24, /16)",
        "ARP resolution: broadcast vs unicast to gateway",
        "Forwarding (inter‑host) vs Routing (end‑to‑end path)",
        "Routing table entries: directly connected, static, dynamic",
        "OSPF link‑state routing using Dijkstra’s algorithm",
        "BGP path‑vector protocol and AS path selection",
        "DHCP discover/offer/ack sequence over UDP ports 67/68",
        "NAT translation table mapping private to public addresses",
        "Static, dynamic, and overload (PAT) NAT configurations",
        "Autonomous System boundaries and inter‑AS vs intra‑AS routing",
        "Data plane processing per router vs control plane decision making"
      ],
      "skills": [
        "Compute subnet ranges and host counts from a given mask",
        "Build and interpret routing table entries for static and dynamic routes",
        "Simulate ARP request/response and update ARP tables",
        "Compare and configure static vs dynamic routing protocols",
        "Analyze BGP path selection and AS path attributes",
        "Design a DHCP lease allocation strategy for a subnet",
        "Configure NAT rules for static, dynamic, and overload scenarios",
        "Evaluate the impact of subnetting on network scalability",
        "Diagnose routing loops and convergence issues",
        "Interpret routing protocol messages (OSPF LSAs, BGP UPDATEs)",
        "Map IP addresses to MAC addresses using ARP",
        "Differentiate between data plane forwarding and control plane routing decisions"
      ],
      "important_terms": [
        "IP",
        "MAC",
        "ARP",
        "DHCP",
        "NAT",
        "CIDR",
        "Subnet mask",
        "OSPF",
        "BGP",
        "RIP",
        "EIGRP",
        "IS-IS",
        "Autonomous System (AS)",
        "Routing table",
        "Forwarding table",
        "Data plane",
        "Control plane",
        "Dijkstra",
        "Path vector",
        "ICANN",
        "RIR",
        "IPv4",
        "IPv6",
        "NAT overload (PAT)",
        "DHCPDISCOVER",
        "DHCPOFFER",
        "DHCPACK",
        "UDP port 67/68"
      ]
    },
    {
      "deck": "OSN_L21.pdf",
      "topics": [
        "Persistence and Volatile Memory",
        "File System Interaction with Disk",
        "Hard Disk Architecture and Geometry",
        "Disk I/O Timing and Performance",
        "Disk Scheduling Algorithms",
        "Cache and Write Policies",
        "RAID Concepts and Trade‑offs"
      ],
      "key_concepts": [
        "Volatile vs persistent storage",
        "File system responsibilities",
        "Sector, track, platter, RPM",
        "Seek time, rotational latency, transfer time",
        "Atomic 512‑byte write, torn write",
        "Track buffer cache",
        "Write‑through vs write‑back policies",
        "SSTF (Shortest Seek Time First)",
        "SCAN/CSCAN/FSCAN scheduling",
        "Starvation in disk scheduling",
        "RAID levels (mirroring, striping, parity)",
        "Performance vs capacity trade‑offs",
        "DMA transfer mechanism",
        "SCSI/SATA interfaces",
        "Cache size impact on throughput",
        "Disk scheduling cost estimation",
        "Sequential vs random workloads",
        "Seek phases (acceleration, coasting, settling)",
        "Track skew optimization"
      ],
      "skills": [
        "Compute seek, rotational, and transfer times for given disk parameters",
        "Analyze and compare random vs sequential I/O performance",
        "Evaluate disk scheduling algorithms and predict throughput",
        "Design cache policies for write‑through and write‑back",
        "Model disk I/O patterns and estimate I/O latency",
        "Compare RAID configurations for reliability and performance",
        "Understand file system interactions with low‑level disk operations",
        "Explain atomicity and torn writes in persistent storage",
        "Apply DMA concepts to disk I/O",
        "Assess starvation risks in scheduling algorithms"
      ],
      "important_terms": [
        "RAM",
        "HDD",
        "SSD",
        "DMA",
        "SCSI",
        "SATA",
        "Sector",
        "Track",
        "Platter",
        "RPM",
        "Seek Time",
        "Rotational Latency",
        "Transfer Rate",
        "Track Buffer Cache",
        "Write‑Through",
        "Write‑Back",
        "SSTF",
        "SCAN",
        "CSCAN",
        "FSCAN",
        "RAID",
        "Mirroring",
        "Striping",
        "Parity",
        "Atomic Write",
        "Torn Write",
        "Capacity",
        "Throughput"
      ]
    },
    {
      "deck": "OSN_L22.pdf",
      "topics": [
        "Disk I/O fundamentals",
        "RAID architecture overview",
        "RAID Level 0 (Striping) performance",
        "RAID Level 1 (Mirroring) read/write behavior",
        "RAID Level 4 (Parity) and small‑write problem",
        "RAID Level 5 (Rotating Parity) improvements",
        "RAID evaluation metrics (capacity, reliability, performance)",
        "Parity calculation and XOR logic",
        "I/O latency modeling in RAID",
        "Practical deployment considerations"
      ],
      "key_concepts": [
        "Striping and chunk size",
        "Mirroring read/write parallelism",
        "Parity block and XOR redundancy",
        "Additive vs subtractive parity",
        "Small‑write bottleneck",
        "Rotating parity to eliminate bottleneck",
        "Capacity overhead per RAID level",
        "Fault tolerance per disk failure",
        "Sequential vs random I/O throughput",
        "Steady‑state throughput formulas",
        "Disk I/O latency components (seek, rotation, transfer)",
        "RAID controller architecture (firmware, DRAM, NV memory)"
      ],
      "skills": [
        "Analyze RAID performance for a given workload",
        "Calculate capacity and reliability of RAID configurations",
        "Model I/O latency for disk and RAID",
        "Compare read/write behavior across RAID levels",
        "Design RAID layout to meet capacity/reliability/performance goals",
        "Explain parity computation and data recovery",
        "Identify bottlenecks in RAID‑4 small‑write scenario",
        "Evaluate trade‑offs between chunk size and parallelism",
        "Interpret throughput equations for sequential/random I/O",
        "Discuss impact of disk characteristics on RAID performance"
      ],
      "important_terms": [
        "RAID",
        "Striping",
        "Mirroring",
        "Parity",
        "XOR",
        "Chunk size",
        "Stripe width",
        "Disk controller",
        "DMA",
        "Seek time",
        "Rotational delay",
        "Transfer rate",
        "Sequential I/O",
        "Random I/O",
        "Steady‑state throughput",
        "Fault tolerance",
        "Additive parity",
        "Subtractive parity",
        "Rotating parity",
        "Small‑write problem",
        "Capacity overhead",
        "Reliability",
        "Performance",
        "Disk failure",
        "Firmware",
        "DRAM",
        "Non‑volatile memory",
        "SCSI",
        "SATA",
        "Disk block",
        "Sector",
        "Track",
        "Head",
        "Arm",
        "OS",
        "File System",
        "Cache",
        "Disk I/O latency",
        "Bandwidth",
        "Disk rotation",
        "Disk spindle",
        "Disk head"
      ]
    },
    {
      "deck": "OSN_L23.pdf",
      "topics": [
        "Persistence Devices & Access Flow",
        "Virtualized Storage: Files & Directories",
        "File System System Calls & Interfaces",
        "File Metadata & Inode Structure",
        "Directory Entries & Linking Mechanisms",
        "Mounting & File System Hierarchy",
        "Designing a Simple File System (VSFS)",
        "On‑Disk Data Structures & Allocation"
      ],
      "key_concepts": [
        "open() flags (O_CREAT, O_WRONLY, O_TRUNC)",
        "read()/write() sequential offset handling",
        "lseek() for random access",
        "fsync() to force disk write",
        "inode as persistent metadata holder",
        "directory as special file with entries",
        "hard link via link() and link count",
        "symbolic link as separate inode",
        "superblock storing layout info",
        "inode table for file metadata",
        "bitmap for free block tracking",
        "block allocation strategy",
        "mounting to attach FS to tree",
        "file descriptor abstraction",
        "disk controller & DMA interaction",
        "sequential vs random I/O performance",
        "data region vs metadata region",
        "file size, timestamps, permissions in inode",
        "directory entries mapping names to i‑nodes"
      ],
      "skills": [
        "Implement open() with creation flags",
        "Use lseek() to reposition file offset",
        "Design and update inode metadata",
        "Create and delete hard links using link()/unlink()",
        "Create and resolve symbolic links",
        "Mount a file system and navigate hierarchy",
        "Build a simple file system layout with superblock, inode table, and bitmaps",
        "Simulate block allocation and free space tracking",
        "Write fsync() logic to ensure persistence",
        "Interpret directory entries and perform directory traversal"
      ],
      "important_terms": [
        "file descriptor",
        "inode number",
        "O_CREAT",
        "O_WRONLY",
        "O_TRUNC",
        "S_IRUSR",
        "S_IWUSR",
        "lseek",
        "SEEK_SET",
        "fsync",
        "superblock",
        "inode table",
        "bitmap",
        "hard link",
        "symbolic link",
        "mount",
        "ext3",
        "block",
        "data region",
        "directory entry",
        "file system",
        "persistence",
        "DMA",
        "disk controller"
      ]
    },
    {
      "deck": "OSN_L24.pdf",
      "topics": [
        "File System Architecture and Access Flow",
        "Inode Structure and Metadata",
        "Block Addressing with Direct and Indirect Pointers",
        "Directory Organization and Pathname Resolution",
        "Free Space Management Techniques",
        "Open File Table and Process Interaction",
        "Read/Write Operations and I/O Overhead",
        "Caching and Buffering Strategies",
        "Performance Tradeoffs: Durability vs Speed"
      ],
      "key_concepts": [
        "Superblock",
        "Inode",
        "Direct Pointers",
        "Single Indirect Pointer",
        "Double Indirect Pointer",
        "Triple Indirect Pointer",
        "Directory Entries",
        "Inode Bitmap",
        "Free Block Bitmap",
        "Open File Table",
        "File Descriptor",
        "Read System Call",
        "Write System Call",
        "Caching (Page Cache)",
        "LRU Eviction",
        "Write Buffering",
        "fsync",
        "Durability",
        "Performance Tradeoff"
      ],
      "skills": [
        "Implement inode lookup and metadata extraction",
        "Design directory traversal algorithm for pathname resolution",
        "Calculate file size from multi-level pointer structures",
        "Simulate free space allocation using bitmap or free list",
        "Model open/read/write sequence and track I/O cost",
        "Implement simple caching policy (LRU) for file blocks",
        "Analyze tradeoffs between durability and performance",
        "Create a basic file system simulator with superblock and inode",
        "Evaluate impact of indirect pointers on large file support"
      ],
      "important_terms": [
        "FS",
        "inode",
        "superblock",
        "block",
        "direct pointer",
        "indirect pointer",
        "double indirect",
        "triple indirect",
        "directory entry",
        "inode bitmap",
        "free block bitmap",
        "open file table",
        "file descriptor",
        "read",
        "write",
        "DMA",
        "LRU",
        "write buffering",
        "fsync",
        "durability",
        "performance tradeoff"
      ]
    },
    {
      "deck": "OSN_L25_revision.pdf",
      "topics": [
        "Process Management and Scheduling",
        "Inter‑Process Communication & Networking Basics",
        "OSI Model and Layered Protocols",
        "Transport Layer: TCP vs UDP",
        "Memory Management: Segmentation & Paging",
        "Concurrency Control: Locks, Semaphores, Producer‑Consumer",
        "Network Layer: IP, Routing, DHCP, NAT",
        "Data Link Layer: MAC, ARP",
        "Physical Layer & Encapsulation",
        "Persistence: Disk Architecture, RAID, File Systems"
      ],
      "key_concepts": [
        "Process state transitions and PCB",
        "Scheduling algorithms (FCFS, Round Robin, etc.)",
        "Socket‑based IPC and network calls",
        "DNS name resolution hierarchy",
        "HTTP statelessness and cookie usage",
        "TCP reliability (handshake, retransmission, flow control)",
        "Segmentation and paging with TLB",
        "Semaphores and mutexes for producer‑consumer",
        "DHCP address allocation over UDP",
        "NAT translation tables and overload",
        "ARP resolution and caching",
        "RAID levels (0,1,5) and striping",
        "Inode structure and file system traversal"
      ],
      "skills": [
        "Analyze process state diagrams and PCB contents",
        "Implement a simple round‑robin scheduler",
        "Design socket‑based client/server IPC",
        "Simulate a DNS lookup sequence",
        "Model the TCP three‑way handshake",
        "Build a paging simulator with TLB support",
        "Use semaphores to solve producer‑consumer deadlocks",
        "Configure a DHCP server for a small subnet",
        "Map IP addresses to MAC via ARP queries",
        "Create a miniature file system using inodes",
        "Simulate RAID 0/1/5 data placement",
        "Explain end‑to‑end encapsulation across OSI layers"
      ],
      "important_terms": [
        "OS",
        "Process",
        "PCB",
        "Scheduling",
        "IPC",
        "Socket",
        "OSI",
        "TCP",
        "UDP",
        "Segmentation",
        "Paging",
        "TLB",
        "Semaphore",
        "Mutex",
        "Producer‑Consumer",
        "DHCP",
        "NAT",
        "ARP",
        "MAC",
        "IP",
        "DNS",
        "HTTP",
        "Cookie",
        "RAID",
        "Inode"
      ]
    }
  ],
  "learning_objectives": [
    "CO-1: Remember the core components and abstractions of an operating system, including process, thread, virtual memory, and networking stack.",
    "CO-2: Understand and explain the mechanisms of process creation, context switching, and scheduling policies (FCFS, RR, SJF, MLFQ) and their impact on system performance.",
    "CO-3: Apply the principles of virtual memory, paging, TLB, and page replacement algorithms to design a memory management simulation that demonstrates page faults and hit rates.",
    "CO-4: Analyze concurrency primitives (mutexes, semaphores, condition variables, spin locks) and evaluate their suitability for solving producer‑consumer and readers‑writers problems, including deadlock and starvation scenarios.",
    "CO-5: Evaluate the trade‑offs of different file system structures (inode, block allocation, caching) and disk scheduling algorithms (SSTF, SCAN) in terms of throughput, latency, and durability.",
    "CO-6: Create a socket‑based client/server application that implements TCP reliability (handshake, retransmission, flow control) and demonstrates the effects of congestion control on throughput.",
    "CO-7: Design a simplified RAID configuration (e.g., RAID‑5) and simulate its performance and fault tolerance under random I/O workloads, justifying the choice of stripe size and parity placement."
  ]
}