{
  "course_title": "Operating Systems and Networks",
  "course_code": "CS3.301",
  "metadata": {
    "source": "All lecture slide decks (text-only)",
    "folder": "/Users/lakshmiprajnapenmetsa/Desktop/iiith/research/irel/honors/dynamic-chunking-and-concept-mapping/raw-data/osn_lecs",
    "framework": "ABCD (Audience, Behavior, Condition, Degree)",
    "model": "gpt-oss:20b-cloud",
    "num_pdfs_found": 25,
    "num_decks_summarized": 25,
    "per_deck_text_truncation_chars": 45000,
    "note": "Per-deck prompts may truncate very long extracted text, but every PDF contributes via per-deck summaries."
  },
  "extraction_report": [
    {
      "deck": "OSN_L01.pdf",
      "extracted_chars": 10059,
      "status": "summarized"
    },
    {
      "deck": "OSN_L02.pdf",
      "extracted_chars": 5474,
      "status": "summarized"
    },
    {
      "deck": "OSN_L03.pdf",
      "extracted_chars": 13324,
      "status": "summarized"
    },
    {
      "deck": "OSN_L04.pdf",
      "extracted_chars": 9910,
      "status": "summarized"
    },
    {
      "deck": "OSN_L05.pdf",
      "extracted_chars": 8930,
      "status": "summarized"
    },
    {
      "deck": "OSN_L06.pdf",
      "extracted_chars": 10774,
      "status": "summarized"
    },
    {
      "deck": "OSN_L07.pdf",
      "extracted_chars": 7832,
      "status": "summarized"
    },
    {
      "deck": "OSN_L08.pdf",
      "extracted_chars": 5554,
      "status": "summarized"
    },
    {
      "deck": "OSN_L09.pdf",
      "extracted_chars": 13821,
      "status": "summarized"
    },
    {
      "deck": "OSN_L10.pdf",
      "extracted_chars": 11824,
      "status": "summarized"
    },
    {
      "deck": "OSN_L11.pdf",
      "extracted_chars": 11282,
      "status": "summarized"
    },
    {
      "deck": "OSN_L12.pdf",
      "extracted_chars": 10542,
      "status": "summarized"
    },
    {
      "deck": "OSN_L13.pdf",
      "extracted_chars": 11592,
      "status": "summarized"
    },
    {
      "deck": "OSN_L14.pdf",
      "extracted_chars": 6345,
      "status": "summarized"
    },
    {
      "deck": "OSN_L15.pdf",
      "extracted_chars": 8878,
      "status": "summarized"
    },
    {
      "deck": "OSN_L16.pdf",
      "extracted_chars": 6799,
      "status": "summarized"
    },
    {
      "deck": "OSN_L17.pdf",
      "extracted_chars": 6209,
      "status": "summarized"
    },
    {
      "deck": "OSN_L18.pdf",
      "extracted_chars": 7122,
      "status": "summarized"
    },
    {
      "deck": "OSN_L19.pdf",
      "extracted_chars": 5699,
      "status": "summarized"
    },
    {
      "deck": "OSN_L20.pdf",
      "extracted_chars": 9810,
      "status": "summarized"
    },
    {
      "deck": "OSN_L21.pdf",
      "extracted_chars": 9782,
      "status": "summarized"
    },
    {
      "deck": "OSN_L22.pdf",
      "extracted_chars": 10477,
      "status": "summarized"
    },
    {
      "deck": "OSN_L23.pdf",
      "extracted_chars": 10985,
      "status": "summarized"
    },
    {
      "deck": "OSN_L24.pdf",
      "extracted_chars": 10107,
      "status": "summarized"
    },
    {
      "deck": "OSN_L25_revision.pdf",
      "extracted_chars": 13093,
      "status": "summarized"
    }
  ],
  "deck_summaries": [
    {
      "deck": "OSN_L01.pdf",
      "topics": [
        "Operating System fundamentals and role",
        "Historical evolution of OS architectures",
        "Abstraction and middleware concepts",
        "Core OS pillars: virtualization, concurrency, persistence",
        "Process and memory management",
        "I/O, device drivers, and file systems",
        "Network fundamentals and OS interaction"
      ],
      "key_concepts": [
        "Virtual memory and paging",
        "Process scheduling and context switching",
        "Concurrency control and thread management",
        "Persistence via file systems and storage devices",
        "Device driver abstraction",
        "System calls and kernel/user space interface",
        "Sockets and TCP/IP networking",
        "Domain Name System (DNS) resolution",
        "Deadlock detection and avoidance",
        "Memory segmentation and protection",
        "I/O scheduling algorithms",
        "Privilege levels and security",
        "Resource allocation and starvation",
        "Interrupt handling and exception processing",
        "Network protocols and subnets"
      ],
      "skills": [
        "Analyze and compare process scheduling algorithms",
        "Implement a simple virtual memory paging simulator",
        "Design a basic file system interface and test I/O operations",
        "Debug and resolve concurrency issues in multithreaded programs",
        "Write socket-based client/server applications using TCP/IP",
        "Evaluate network protocol behavior and performance",
        "Identify and mitigate deadlock scenarios in OS",
        "Simulate memory allocation strategies (e.g., first-fit, best-fit)",
        "Create a minimal device driver skeleton",
        "Assess OS security mechanisms and privilege isolation"
      ],
      "important_terms": [
        "Operating System (OS)",
        "Kernel",
        "User space",
        "System call",
        "Virtual memory",
        "Paging",
        "Segmentation",
        "Context switch",
        "Process",
        "Thread",
        "Scheduler",
        "I/O",
        "Device driver",
        "File system",
        "Disk",
        "SSD",
        "Network",
        "Socket",
        "TCP/IP",
        "DNS",
        "ARPANET",
        "Subnet",
        "Router",
        "Switch",
        "Protocol",
        "Abstraction",
        "Concurrency",
        "Persistence",
        "Deadlock",
        "Starvation",
        "Priority inversion",
        "Interrupt",
        "Privilege level",
        "Kernel mode",
        "User mode"
      ]
    },
    {
      "deck": "OSN_L02.pdf",
      "topics": [
        "Process Fundamentals",
        "CPU Virtualization & Context Switching",
        "Process States & Transitions",
        "Process Control Block & Data Structures",
        "Process Creation & Lazy Loading",
        "Hardware Pipeline Basics",
        "Xv6 Operating System Example",
        "I/O Blocking & Scheduling"
      ],
      "key_concepts": [
        "Process vs Program",
        "Process ID",
        "Address Space",
        "Memory Image (Code, Stack, Heap)",
        "CPU Context (Registers, PC, SP)",
        "File Descriptors",
        "Process States (Running, Ready, Blocked)",
        "State Transitions",
        "Context Switch",
        "CPU Scheduler & Time Slice",
        "Lazy Loading of Executables",
        "Process List",
        "Process Control Block (PCB)",
        "Superscalar Pipeline",
        "Three‑Stage Pipeline (Fetch, Decode, Execute)",
        "Virtualization of CPU",
        "I/O Blocking",
        "Xv6 Process Structure"
      ],
      "skills": [
        "Analyze process state diagrams",
        "Implement a context‑switch simulation",
        "Design a PCB data structure",
        "Simulate process creation and lazy loading",
        "Model I/O blocking and state transitions",
        "Evaluate simple scheduling policies",
        "Explain CPU virtualization concepts",
        "Trace a process lifecycle in Xv6",
        "Compare Xv6 process fields to OS theory",
        "Interpret process list entries"
      ],
      "important_terms": [
        "Process",
        "Program",
        "Process ID",
        "Address Space",
        "Memory Image",
        "Code",
        "Stack",
        "Heap",
        "Registers",
        "Program Counter",
        "Stack Pointer",
        "File Descriptor",
        "I/O",
        "Lazy Loading",
        "Ready State",
        "Blocked State",
        "Running State",
        "State Transition",
        "Context Switch",
        "CPU Scheduler",
        "Time Slice",
        "Process Control Block",
        "Process List",
        "Superscalar",
        "Pipeline",
        "Fetch",
        "Decode",
        "Execute",
        "Xv6"
      ]
    },
    {
      "deck": "OSN_L03.pdf",
      "topics": [
        "Process Creation and Execution APIs",
        "System Call Mechanism and Privilege Separation",
        "Process Virtualisation and LDE",
        "Process Lifecycle and Zombie Prevention",
        "Cooperative vs Preemptive Multitasking",
        "Timer Interrupts and Context Switching",
        "Shell Operation and Command Execution",
        "POSIX API and OS Portability"
      ],
      "key_concepts": [
        "fork()",
        "exec()",
        "wait()",
        "exit()",
        "system call interface",
        "trap instruction",
        "Interrupt Descriptor Table (IDT)",
        "kernel stack",
        "user mode",
        "kernel mode",
        "Limited Direct Execution (LDE)",
        "context switch",
        "timer interrupt",
        "scheduler",
        "process image",
        "process list",
        "pipe",
        "file descriptor",
        "POSIX compliance",
        "privileged instruction"
      ],
      "skills": [
        "simulate fork/exec lifecycle",
        "write system call wrappers",
        "analyze process state transitions",
        "design context switch routine",
        "implement timer interrupt handler",
        "debug zombie processes",
        "understand user/kernel mode switching",
        "evaluate preemptive vs cooperative scheduling",
        "use POSIX API for portability",
        "interpret trap handling in assembly"
      ],
      "important_terms": [
        "fork",
        "exec",
        "wait",
        "exit",
        "system call",
        "trap",
        "IDT",
        "kernel stack",
        "user mode",
        "kernel mode",
        "LDE",
        "context switch",
        "timer interrupt",
        "scheduler",
        "process image",
        "process list",
        "pipe",
        "file descriptor",
        "POSIX",
        "privileged instruction",
        "interrupt",
        "exception",
        "syscall handler",
        "return-from-trap"
      ]
    },
    {
      "deck": "OSN_L04.pdf",
      "topics": [
        "Process and privilege modes",
        "Trap and system‑call mechanism",
        "Interrupt handling and timer interrupts",
        "Context switching and scheduler design",
        "Scheduling algorithms and performance metrics",
        "Cooperative vs preemptive scheduling"
      ],
      "key_concepts": [
        "TRAP instruction",
        "Return‑from‑trap",
        "Interrupt Descriptor Table (IDT)",
        "Kernel stack vs user stack",
        "System call handling",
        "Timer interrupt for preemption",
        "Context switch routine",
        "Scheduler component",
        "First‑Come‑First‑Serve (FCFS)",
        "Shortest‑Job‑First (SJF)",
        "Shortest‑Time‑to‑Completion‑First (STCF)",
        "Preemptive vs non‑preemptive scheduling",
        "Cooperative scheduling (yield)",
        "LDE protocol steps",
        "Process control block (PCB)",
        "Turnaround time metric",
        "Fairness (Jain’s index)",
        "Interrupt disabling during handler"
      ],
      "skills": [
        "Analyze turnaround and fairness for given job sets",
        "Implement a simple context‑switch routine in assembly",
        "Design a scheduler that chooses next process based on remaining time",
        "Simulate timer‑interrupt‑driven preemption",
        "Compare cooperative and preemptive scheduling scenarios",
        "Compute metrics for FCFS, SJF, STCF policies",
        "Explain the role of IDT in trap handling",
        "Describe how privilege modes protect kernel code",
        "Model the LDE protocol flow for process creation and exit"
      ],
      "important_terms": [
        "TRAP",
        "Return‑from‑trap",
        "IDT",
        "Kernel stack",
        "User stack",
        "Interrupt",
        "System call",
        "Timer interrupt",
        "Context switch",
        "Scheduler",
        "FCFS",
        "SJF",
        "STCF",
        "Preemption",
        "Cooperative scheduling",
        "Non‑preemptive scheduling",
        "LDE protocol",
        "Process control block (PCB)",
        "Turnaround time",
        "Fairness index",
        "Privilege mode",
        "Kernel mode",
        "User mode"
      ]
    },
    {
      "deck": "OSN_L05.pdf",
      "topics": [
        "Process Scheduling Policies",
        "Round Robin & Time Slices",
        "Shortest Time to Completion First (STCF)",
        "I/O Handling in Scheduling",
        "Priority Scheduling & Starvation",
        "Multi‑Level Feedback Queue (MLFQ)",
        "Priority Boost & Gaming Prevention",
        "Tuning & Parameter Selection",
        "Process Communication Basics"
      ],
      "key_concepts": [
        "Round Robin scheduling and time quantum",
        "Context switch overhead and its impact on response time",
        "Response time vs turnaround time trade‑offs",
        "I/O blocking and interrupt‑driven state transitions",
        "Shortest Time to Completion First (STCF) as a preemptive SJF variant",
        "Priority scheduling and dynamic priority assignment",
        "Multi‑Level Feedback Queue structure and rules",
        "Priority boost mechanism to prevent starvation",
        "Gaming the scheduler via early relinquishment",
        "Tuning MLFQ parameters (queues, slices, boost interval)",
        "Process states: ready, running, blocked, terminated",
        "Preemptive vs non‑preemptive scheduling"
      ],
      "skills": [
        "Analyze response vs turnaround time for different policies",
        "Compute average turnaround and response times in RR scenarios",
        "Design a scheduler that handles I/O blocking efficiently",
        "Implement a basic MLFQ simulator in code",
        "Identify and mitigate starvation in priority schedulers",
        "Tune MLFQ parameters for mixed workloads",
        "Model process state transitions during I/O bursts",
        "Compare STCF and RR in terms of fairness and efficiency",
        "Explain how OS supports inter‑process communication across machines"
      ],
      "important_terms": [
        "Round Robin (RR)",
        "Time slice (quantum)",
        "Context switch",
        "Response time",
        "Turnaround time",
        "Shortest Time to Completion First (STCF)",
        "I/O blocking",
        "Interrupt",
        "Priority scheduling",
        "Priority queue",
        "Multi‑Level Feedback Queue (MLFQ)",
        "Priority boost",
        "Starvation",
        "Gaming the scheduler",
        "Preemption",
        "Ready queue",
        "Blocked queue",
        "CPU burst",
        "I/O burst",
        "Process state",
        "Scheduler",
        "Fairness",
        "Throughput"
      ]
    },
    {
      "deck": "OSN_L06.pdf",
      "topics": [
        "Network fundamentals and host communication",
        "Addressing and routing (IP, MAC, routers)",
        "Network devices and topology (repeaters, hubs, bridges, switches, routers)",
        "Network types and scales (PAN, LAN, MAN, WAN)",
        "Process-to-process communication over networks",
        "OSI layered architecture",
        "TCP/IP 4-layer model",
        "Encapsulation and packet structure",
        "Common network protocols (HTTP, SMTP, DNS, TCP, UDP, ICMP)"
      ],
      "key_concepts": [
        "Host vs. client-server roles",
        "IPv4 addressing and subnetting",
        "MAC addressing",
        "Routing and routing tables",
        "Functions of repeaters, hubs, bridges, switches, routers",
        "Layered network architecture",
        "OSI model layers and responsibilities",
        "TCP/IP model layers",
        "Encapsulation/decapsulation process",
        "End-to-end vs hop-to-hop communication",
        "Port numbers and process identification",
        "Transport protocols (TCP, UDP)",
        "Network protocols (IP, ICMP, ARP)",
        "Virtual LANs (VLANs)",
        "Network interfaces and drivers"
      ],
      "skills": [
        "Analyze end-to-end communication paths",
        "Determine appropriate addressing scheme (IP/MAC)",
        "Configure routing tables",
        "Explain encapsulation process",
        "Differentiate between OSI and TCP/IP models",
        "Identify roles of network devices",
        "Interpret packet headers",
        "Map application ports to services",
        "Troubleshoot basic network connectivity issues"
      ],
      "important_terms": [
        "Host",
        "Client",
        "Server",
        "IP address",
        "MAC address",
        "Router",
        "Switch",
        "Hub",
        "Bridge",
        "Repeater",
        "VLAN",
        "OSI model",
        "TCP/IP model",
        "Layer 1 Physical",
        "Layer 2 Data Link",
        "Layer 3 Network",
        "Layer 4 Transport",
        "Port number",
        "TCP",
        "UDP",
        "ICMP",
        "ARP",
        "Encapsulation",
        "Decapsulation",
        "Routing table"
      ]
    },
    {
      "deck": "OSN_L07.pdf",
      "topics": [
        "Transport Layer Fundamentals",
        "Socket API and System Calls",
        "Port Management and Addressing",
        "Multiplexing & Demultiplexing",
        "Connection-Oriented vs Connectionless Services",
        "TCP Reliability and Flow Control",
        "UDP Features and Checksum",
        "Operating System Interaction with Networking"
      ]
    },
    {
      "deck": "OSN_L08.pdf",
      "topics": [
        "TCP Fundamentals",
        "TCP Header Fields",
        "Reliability & Retransmission",
        "Flow Control & Congestion",
        "Connection Management (3‑way Handshake & Termination)",
        "Memory Virtualization Overview",
        "Virtual Address Space",
        "Memory Management Unit & Address Translation"
      ],
      "key_concepts": [
        "Sequence Number & Acknowledgement Number",
        "Window Size & Flow Control",
        "Delayed ACK Strategy",
        "RTT Estimation & Timeout Interval",
        "Three‑Way Handshake Process",
        "FIN & RST Flags for Connection Closure",
        "Virtual Memory & Process Isolation",
        "Virtual Address Space Layout (Code, Heap, Stack)",
        "Physical Memory Mapping via MMU",
        "Page Table Entries & Address Translation"
      ],
      "skills": [
        "Calculate RTT and Timeout Interval",
        "Implement TCP retransmission logic",
        "Simulate a 3‑way handshake sequence",
        "Analyze flow control with dynamic window sizing",
        "Design a delayed ACK mechanism",
        "Create a virtual memory mapping simulator",
        "Write and manipulate page table entries",
        "Simulate address translation from VA to PA",
        "Evaluate memory fragmentation scenarios",
        "Develop a memory allocation strategy for processes"
      ],
      "important_terms": [
        "TCP",
        "SYN",
        "ACK",
        "FIN",
        "RST",
        "Sequence Number",
        "Acknowledgement Number",
        "Window Size",
        "Flow Control",
        "Congestion Control",
        "RTT",
        "Timeout Interval",
        "Delayed ACK",
        "Three‑Way Handshake",
        "Virtual Memory",
        "Virtual Address Space",
        "Physical Memory",
        "MMU",
        "Page Table",
        "Address Translation",
        "Memory Protection",
        "Process Isolation"
      ]
    },
    {
      "deck": "OSN_L09.pdf",
      "topics": [
        "Memory allocation in C (stack vs heap)",
        "Common memory management pitfalls",
        "Memory allocation APIs (malloc, free, calloc, realloc, mmap, brk/sbrk)",
        "Virtual memory goals (transparency, efficiency, protection)",
        "Dynamic relocation (base & bounds registers)",
        "Segmentation (logical segments, segment registers)",
        "Address translation (VA to PA)",
        "Bounds checking & protection bits",
        "External fragmentation & compaction",
        "Hardware support for memory management (MMU, segment tables)"
      ],
      "key_concepts": [
        "malloc/free semantics",
        "Segmentation fault causes",
        "Dangling pointer & double free",
        "Memory leak detection",
        "brk/sbrk system calls",
        "mmap for anonymous memory",
        "Base register + bounds register for dynamic relocation",
        "Segment register mapping",
        "Virtual address space vs physical address space",
        "Bounds checking during translation",
        "Protection bits for read/write/execute",
        "External fragmentation in physical memory",
        "Compaction algorithm for memory reuse",
        "Coarse‑grained vs fine‑grained segmentation",
        "Segment table storage and lookup"
      ],
      "skills": [
        "Analyze memory allocation errors in C programs",
        "Simulate malloc/free behavior in a toy allocator",
        "Translate virtual addresses to physical addresses using base/bounds registers",
        "Implement bounds checking and detect segmentation faults",
        "Design a compaction routine to reduce fragmentation",
        "Configure and use mmap for anonymous memory mapping",
        "Debug memory leaks with tools like valgrind",
        "Evaluate trade‑offs between coarse‑ and fine‑grained segmentation",
        "Manage segment tables during context switches",
        "Apply protection bits to enforce memory access policies"
      ],
      "important_terms": [
        "malloc",
        "free",
        "calloc",
        "realloc",
        "mmap",
        "brk",
        "sbrk",
        "segmentation fault",
        "dangling pointer",
        "double free",
        "memory leak",
        "base register",
        "bounds register",
        "segment register",
        "MMU",
        "dynamic relocation",
        "address translation",
        "virtual address",
        "physical address",
        "bounds checking",
        "protection bits",
        "external fragmentation",
        "compaction",
        "coarse‑grained segmentation",
        "fine‑grained segmentation"
      ]
    },
    {
      "deck": "OSN_L10.pdf",
      "topics": [
        "Memory Virtualization & Segmentation",
        "External vs Internal Fragmentation",
        "Paging Fundamentals",
        "Page Table Structure & Management",
        "Translation Lookaside Buffer (TLB)",
        "TLB Miss Handling & Context Switching",
        "Address Space Identifier (ASID) & Page Sharing",
        "Efficiency & Hardware Support"
      ],
      "key_concepts": [
        "Segmentation and bounds checking",
        "External fragmentation and compaction",
        "Paging and fixed‑size pages",
        "Virtual Page Number (VPN) and Page Frame Number (PFN) mapping",
        "Page Table Entry (PTE) fields (valid, present, dirty, reference, protection)",
        "Page Table Base Register (PTBR) and page table walk",
        "Translation Lookaside Buffer (TLB) as a cache of VA→PA translations",
        "TLB hit/miss control flow",
        "Hardware vs software TLB miss handling",
        "Context switch effects on TLB and page tables",
        "Address Space Identifier (ASID) for multi‑process TLB entries",
        "Page sharing across processes",
        "Memory allocation algorithms (best‑fit, first‑fit, buddy)",
        "Internal fragmentation due to fixed page size",
        "Page fault handling and trap mechanisms",
        "Page table size and memory overhead",
        "TLB replacement policies",
        "TLB entry validity and protection bits",
        "Page table entry dirty and reference bits"
      ],
      "skills": [
        "Compute virtual to physical address translation using VPN and offset",
        "Design and implement a simple page table data structure",
        "Simulate TLB behavior and calculate hit rates",
        "Analyze and mitigate external fragmentation via compaction",
        "Evaluate TLB miss handling strategies in hardware and software",
        "Implement context switch handling for page tables and TLB entries",
        "Apply memory allocation algorithms to minimize fragmentation",
        "Interpret and manipulate PTE bits for protection and status",
        "Design page sharing schemes using ASID",
        "Optimize paging performance by tuning page size and TLB size"
      ],
      "important_terms": [
        "Segmentation",
        "External Fragmentation",
        "Internal Fragmentation",
        "Paging",
        "Virtual Address",
        "Physical Address",
        "Virtual Page Number (VPN)",
        "Page Frame Number (PFN)",
        "Page Table",
        "Page Table Entry (PTE)",
        "Page Table Base Register (PTBR)",
        "Translation Lookaside Buffer (TLB)",
        "TLB Hit",
        "TLB Miss",
        "Address Space Identifier (ASID)",
        "Page Fault",
        "Page Frame",
        "Page Size",
        "Offset",
        "Valid Bit",
        "Present Bit",
        "Dirty Bit",
        "Reference Bit",
        "Protection Bit",
        "Memory Allocation Algorithm",
        "Page Sharing"
      ]
    },
    {
      "deck": "OSN_L11.pdf",
      "topics": [
        "Virtual Memory Fundamentals",
        "TLB Operation and Miss Handling",
        "Page Table Structures and Management",
        "Multi-level Page Tables",
        "Hybrid Paging and Segmentation",
        "Context Switching and ASID",
        "Page Size Trade-offs and Fragmentation",
        "Inverted Page Tables and Alternatives"
      ],
      "key_concepts": [
        "Virtual Address Space (VAS)",
        "Page Size and Offset Bits",
        "Page Table Entry (PTE) fields (valid, protection, PFN, dirty, ASID)",
        "Translation Lookaside Buffer (TLB) and Associativity",
        "TLB Miss Handling (Hardware vs Software)",
        "Page Directory (PD) and Page Table (PT)",
        "Multi-level Page Table Hierarchy",
        "Address Space Identifier (ASID) for TLB tagging",
        "Page Table Size Reduction via Multi-level",
        "Hybrid Paging and Segmentation (Base/Bound registers)",
        "Page Size Impact on Internal Fragmentation",
        "Inverted Page Table concept",
        "Swap Space and Page Replacement",
        "Context Switch and TLB Flush vs ASID",
        "Page Fault Handling"
      ],
      "skills": [
        "Analyze TLB hit/miss patterns",
        "Compute virtual-to-physical address translation",
        "Design and implement a multi-level page table",
        "Evaluate trade-offs of page size on fragmentation",
        "Implement a software TLB miss handler",
        "Explain context switch effects on TLB and ASID",
        "Compare linear and multi-level page tables",
        "Discuss hybrid paging and segmentation design",
        "Optimize page table memory usage",
        "Simulate page fault handling and swapping",
        "Evaluate TLB replacement policies",
        "Use base and bound registers for segmentation"
      ],
      "important_terms": [
        "Virtual Address (VA)",
        "Physical Address (PA)",
        "Page Size",
        "Page Offset",
        "Virtual Page Number (VPN)",
        "Page Frame Number (PFN)",
        "Page Table Entry (PTE)",
        "Translation Lookaside Buffer (TLB)",
        "ASID (Address Space Identifier)",
        "Page Directory",
        "Page Directory Entry (PDE)",
        "Multi-level Page Table",
        "Segmentation",
        "Base Register",
        "Bound Register",
        "Swap Space",
        "Page Fault",
        "TLB Miss",
        "TLB Hit",
        "Page Table Base Register (PTBR)",
        "Inverted Page Table",
        "Page Replacement Policy",
        "Dirty Bit",
        "Protection Bits (rwx)",
        "Fully Associative"
      ]
    },
    {
      "deck": "OSN_L12.pdf",
      "topics": [
        "Memory Virtualization",
        "Paging Mechanisms",
        "Swap Space & Disk I/O",
        "Page Fault Handling",
        "Page Replacement Policies",
        "TLB & Address Translation",
        "Accessed/Dirty Bit Utilization",
        "Belady’s Anomaly & Random Replacement",
        "Clock Algorithm & LRU Approximation",
        "Thrashing & Admission Control"
      ],
      "key_concepts": [
        "Demand paging",
        "Swap space management",
        "Page fault handler flow",
        "Present bit usage",
        "Page table entry (PTE) fields",
        "Optimal (MIN) replacement",
        "FIFO replacement",
        "LRU replacement",
        "Clock algorithm",
        "Random replacement",
        "Belady’s anomaly",
        "AMAT calculation",
        "Memory access time trade‑offs",
        "Thrashing detection",
        "Admission control",
        "TLB miss handling",
        "Accessed bit for LRU",
        "Dirty bit for write‑back",
        "Page frame number (PFN)",
        "Page size and VPN/offset"
      ],
      "skills": [
        "Implement a paging simulator",
        "Analyze page fault rates and AMAT",
        "Design and evaluate page replacement algorithms",
        "Explain TLB miss and page fault handling",
        "Compute memory access times under different policies",
        "Identify and mitigate thrashing scenarios",
        "Use swap space effectively in multi‑programming",
        "Interpret PTE bits for present, accessed, dirty",
        "Apply LRU using hardware bits",
        "Assess impact of Belady’s anomaly on system performance"
      ],
      "important_terms": [
        "virtual address",
        "physical address",
        "page frame number",
        "page table",
        "TLB",
        "page fault",
        "swap space",
        "present bit",
        "accessed bit",
        "dirty bit",
        "page replacement algorithm",
        "optimal (MIN)",
        "FIFO",
        "LRU",
        "Clock",
        "random replacement",
        "Belady’s anomaly",
        "thrashing",
        "memory access time",
        "AMAT",
        "demand paging"
      ]
    },
    {
      "deck": "OSN_L13.pdf",
      "topics": [
        "Application Layer Protocols",
        "HTTP Fundamentals",
        "HTTP Connections & Status Codes",
        "Cookies & Session Management",
        "Web Caching & CDNs",
        "Domain Name System (DNS)",
        "DNS Records & Resolution"
      ],
      "key_concepts": [
        "HTTP request/response structure (method, URL, headers, body)",
        "Persistent vs Non‑persistent HTTP connections",
        "HTTP status codes (200, 301, 400, 404, 505)",
        "Cookies for client‑side state persistence",
        "Web cache hit/miss logic and proxy servers",
        "Conditional GET using If‑Modified‑Since and Last‑Modified",
        "Content Distribution Network (CDN) server placement strategies",
        "DNS hierarchical distributed database",
        "DNS resource record types (A, CNAME, NS, MX)",
        "TTL and caching in DNS",
        "DNS resolution flow (recursive vs iterative)",
        "HTTP/2 multiplexing and header compression",
        "HTTP/3 QUIC transport"
      ],
      "skills": [
        "Implement a simple HTTP client and server",
        "Analyze and optimize HTTP persistent connections",
        "Design a web caching mechanism for a proxy server",
        "Configure and manage DNS records (A, CNAME, MX, NS)",
        "Simulate CDN placement and evaluate latency",
        "Implement cookie‑based session tracking",
        "Use conditional GET to reduce bandwidth",
        "Interpret HTTP status codes for debugging",
        "Explain DNS resolution steps in a network diagram"
      ],
      "important_terms": [
        "HTTP",
        "TCP",
        "UDP",
        "Port 80",
        "Port 53",
        "GET",
        "POST",
        "Persistent Connection",
        "Non‑persistent Connection",
        "Status Code",
        "Cookies",
        "Web Cache",
        "Proxy Server",
        "CDN",
        "DNS",
        "A Record",
        "CNAME",
        "NS Record",
        "MX Record",
        "TTL",
        "Conditional GET",
        "Last‑Modified",
        "HTTP/2",
        "HTTP/3",
        "BIND"
      ]
    },
    {
      "deck": "OSN_L14.pdf",
      "topics": [
        "Process vs Thread fundamentals",
        "Threading model and address‑space sharing",
        "Concurrency vs Parallelism",
        "Thread scheduling and context switching",
        "Kernel vs User threads",
        "POSIX thread API and creation",
        "Thread lifecycle and attributes",
        "Shared data and race conditions",
        "Non‑deterministic execution",
        "Synchronization mechanisms (conceptual)"
      ],
      "key_concepts": [
        "Process",
        "Thread",
        "Address space sharing",
        "Program Counter (PC)",
        "Stack Pointer (SP)",
        "Copy‑on‑Write (CoW)",
        "Thread Control Block (TCB)",
        "Process Control Block (PCB)",
        "Kernel thread",
        "User thread",
        "POSIX pthread_create",
        "Concurrency",
        "Parallelism",
        "Context switch",
        "Non‑determinism",
        "Race condition"
      ],
      "skills": [
        "Explain differences between processes and threads",
        "Create and manage threads using pthread_create",
        "Analyze thread scheduling and context switches",
        "Distinguish concurrency from parallelism",
        "Predict non‑deterministic thread interleavings",
        "Identify and reason about race conditions",
        "Design thread‑safe shared data access",
        "Describe kernel vs user thread roles",
        "Use thread attributes for scheduling policies",
        "Simulate thread lifecycle and control blocks"
      ],
      "important_terms": [
        "Process",
        "Thread",
        "Address Space",
        "Program Counter",
        "Stack Pointer",
        "Copy‑on‑Write",
        "Thread Control Block",
        "Process Control Block",
        "Kernel Thread",
        "User Thread",
        "POSIX",
        "pthread_create",
        "Concurrency",
        "Parallelism",
        "Context Switch",
        "Non‑Determinism",
        "Race Condition",
        "Synchronization",
        "Shared Memory",
        "System Call",
        "Interrupt"
      ]
    },
    {
      "deck": "OSN_L15.pdf",
      "topics": [
        "Concurrency fundamentals",
        "Race conditions and critical sections",
        "Mutual exclusion and lock concepts",
        "Hardware-supported atomic primitives",
        "Spin locks and their evaluation",
        "Ticket locks and fairness mechanisms",
        "Software vs hardware lock design",
        "Performance and starvation considerations"
      ],
      "key_concepts": [
        "Race condition",
        "Critical section",
        "Mutual exclusion",
        "Lock variable (flag)",
        "Test-and-Set instruction",
        "Compare-and-Swap (CAS)",
        "Load-Linked / Store-Conditional (LL/SC)",
        "Fetch-and-Add",
        "Spin lock",
        "Ticket lock",
        "Fairness vs starvation",
        "Atomicity",
        "Interrupt masking",
        "Preemption",
        "Hardware synchronization primitive"
      ],
      "skills": [
        "Identify and analyze race conditions in concurrent code",
        "Define and isolate critical sections",
        "Implement spin locks using test-and-set",
        "Build ticket locks with fetch-and-add",
        "Evaluate lock fairness and potential for starvation",
        "Assess performance overhead of different lock types",
        "Use hardware atomic primitives to enforce mutual exclusion",
        "Debug concurrency bugs caused by improper locking",
        "Design lock-free data structures using LL/SC",
        "Explain the impact of interrupts and preemption on locks"
      ],
      "important_terms": [
        "Race condition",
        "Critical section",
        "Mutual exclusion",
        "Lock",
        "Test-and-Set",
        "Compare-and-Swap",
        "Load-Linked",
        "Store-Conditional",
        "Fetch-and-Add",
        "Spin lock",
        "Ticket lock",
        "Atomicity",
        "Starvation",
        "Fairness",
        "Preemption",
        "Interrupt masking",
        "Atomic instruction",
        "Synchronization primitive",
        "Lock acquisition",
        "Lock release"
      ]
    },
    {
      "deck": "OSN_L16.pdf",
      "topics": [
        "Ticket Locks & Spin Locks",
        "OS Yield and Parking Primitives",
        "Condition Variables and Join",
        "Producer‑Consumer Bounded Buffer",
        "Semaphores and Dijkstra’s Solution"
      ],
      "key_concepts": [
        "Ticket lock (ticket+turn variables)",
        "Fetch‑and‑Add primitive",
        "Spin lock inefficiency and CPU waste",
        "Yield syscall to relinquish CPU",
        "park()/unpark() for sleeping threads",
        "Condition variable wait() and signal()",
        "Join semantics with state variable",
        "While loop guard for condition checks",
        "Two condition variables for producer/consumer",
        "Bounded buffer with empty/full flags",
        "Buffer indexing (fill/use pointers)",
        "Semaphore as atomic counter",
        "Dijkstra’s semaphore for producer/consumer"
      ],
      "skills": [
        "Implement ticket lock using fetch‑and‑add",
        "Use yield to avoid busy‑waiting in lock acquisition",
        "Employ park/unpark to sleep and wake threads",
        "Design and use condition variables for thread synchronization",
        "Implement join with state variable and signaling",
        "Solve producer‑consumer problem with two condition variables",
        "Build a bounded buffer with proper synchronization",
        "Apply semaphores to coordinate multiple producers/consumers",
        "Analyze race conditions and starvation scenarios",
        "Debug deadlock and livelock in concurrent code"
      ],
      "important_terms": [
        "ticket lock",
        "fetch‑and‑add",
        "spin lock",
        "yield",
        "park",
        "unpark",
        "condition variable",
        "pthread_cond_t",
        "wait",
        "signal",
        "join",
        "state variable",
        "while guard",
        "producer",
        "consumer",
        "bounded buffer",
        "empty flag",
        "full flag",
        "buffer indexing",
        "semaphore",
        "Dijkstra semaphore",
        "critical section",
        "race condition",
        "starvation"
      ]
    },
    {
      "deck": "OSN_L17.pdf",
      "topics": [
        "Concurrency Primitives",
        "Producer‑Consumer Problem",
        "Semaphore Fundamentals",
        "Condition Variables & Locks",
        "Readers‑Writers Problem",
        "Deadlock & Race Conditions",
        "POSIX Semaphore API",
        "Synchronization Patterns",
        "Binary vs Counting Semaphores",
        "Classical Concurrency Solutions"
      ],
      "key_concepts": [
        "Semaphore (binary & counting)",
        "wait (P) operation",
        "post (V) operation",
        "sem_wait() and sem_post()",
        "Mutex as binary semaphore",
        "Condition variable via semaphores",
        "Producer‑Consumer buffer management",
        "Empty and Full semaphores",
        "Readers‑Writers priority scheme",
        "Deadlock prevention",
        "Race condition avoidance",
        "Buffer indexing (fill/use)",
        "POSIX semaphore initialization",
        "Semaphore value semantics",
        "Two‑condition‑variable approach"
      ],
      "skills": [
        "Implement producer‑consumer with semaphores",
        "Use binary semaphore as lock",
        "Design readers‑writers solution",
        "Analyze and resolve deadlocks",
        "Identify and fix race conditions",
        "Apply POSIX semaphore API",
        "Reason about semaphore values",
        "Simulate buffer operations",
        "Evaluate priority‑based synchronization",
        "Debug synchronization bugs"
      ],
      "important_terms": [
        "semaphore",
        "binary semaphore",
        "counting semaphore",
        "wait (P)",
        "post (V)",
        "sem_wait",
        "sem_post",
        "mutex",
        "condition variable",
        "producer",
        "consumer",
        "buffer",
        "empty",
        "full",
        "deadlock",
        "race condition",
        "mutual exclusion",
        "POSIX",
        "Dijkstra",
        "signaling",
        "priority",
        "readers",
        "writers"
      ]
    },
    {
      "deck": "OSN_L18.pdf",
      "topics": [
        "Classical concurrency problems",
        "Readers/Writers problem",
        "Dining Philosophers problem",
        "Concurrency bug taxonomy",
        "Atomicity and order violations",
        "Deadlock theory",
        "Deadlock prevention techniques",
        "Deadlock avoidance and detection",
        "Hardware atomic primitives"
      ],
      "key_concepts": [
        "Readers/Writers solution with priority queue",
        "Dining Philosophers solution via lock ordering",
        "Atomicity violation example",
        "Order violation example",
        "Deadlock conditions (mutual exclusion, hold‑and‑wait, no preemption, circular wait)",
        "Lock ordering to prevent circular wait",
        "Trylock to avoid livelock",
        "Compare‑and‑swap for lock‑free updates",
        "Deadlock avoidance via scheduling",
        "Deadlock detection using resource graph",
        "Banker’s algorithm (conceptual)"
      ],
      "skills": [
        "Analyze deadlock scenarios in multi‑threaded programs",
        "Design and implement a readers/writers solution",
        "Implement dining philosophers without deadlock or starvation",
        "Identify atomicity violations in concurrent code",
        "Use condition variables and semaphores to enforce execution order",
        "Apply lock ordering to prevent deadlock",
        "Employ trylock to avoid livelock",
        "Utilize compare‑and‑swap for lock‑free data structures",
        "Detect deadlock cycles in a resource graph",
        "Recover from deadlock by aborting or restarting transactions",
        "Schedule threads to avoid resource contention"
      ],
      "important_terms": [
        "semaphore",
        "mutex",
        "condition variable",
        "atomicity",
        "order violation",
        "deadlock",
        "livelock",
        "mutual exclusion",
        "hold‑and‑wait",
        "no preemption",
        "circular wait",
        "lock ordering",
        "trylock",
        "compare‑and‑swap",
        "hardware atomic",
        "Banker’s algorithm",
        "resource graph",
        "scheduling",
        "deadlock detection",
        "deadlock recovery",
        "starvation",
        "priority queue"
      ]
    },
    {
      "deck": "OSN_L19.pdf",
      "topics": [
        "Link Layer responsibilities",
        "MAC addressing and format",
        "Address Resolution Protocol (ARP)",
        "ARP cache and TTL",
        "Subnetting and CIDR notation",
        "Host-to-host communication within same network",
        "Host-to-host communication across networks",
        "Role of the Network Layer"
      ],
      "key_concepts": [
        "Encapsulation hierarchy (Application→Transport→Network→Data Link→Physical)",
        "Link Layer handles hop‑to‑hop delivery",
        "MAC address: 48‑bit IEEE format (OUI + NIC)",
        "ARP request broadcast to resolve IP→MAC",
        "ARP response unicast updates ARP cache",
        "ARP cache entries expire after TTL (≈20 min)",
        "Subnet mask / CIDR defines network vs host bits",
        "Default gateway IP used for out‑of‑subnet traffic",
        "Broadcast MAC FF:FF:FF:FF:FF:FF",
        "IP address is logical, MAC is physical",
        "Link Layer provides flow control and error detection",
        "Switch forwards frames based on MAC table",
        "Router forwards packets based on IP routing table",
        "Host determines if destination is local via subnet mask",
        "ARP cache is shared among all protocols on the host"
      ],
      "skills": [
        "Construct and parse an ARP request packet",
        "Update and query an ARP cache",
        "Calculate subnet mask and CIDR range",
        "Identify default gateway for a given IP",
        "Explain why MAC addresses are needed for local delivery",
        "Differentiate between IP and MAC addressing schemes",
        "Analyze host-to-host communication steps in same vs different networks",
        "Determine when to broadcast ARP vs send to gateway",
        "Interpret encapsulation layers for a data frame",
        "Troubleshoot ARP resolution failures"
      ],
      "important_terms": [
        "ARP",
        "MAC address",
        "IP address",
        "Subnet mask",
        "CIDR",
        "Default gateway",
        "Broadcast address",
        "ARP cache",
        "TTL",
        "Encapsulation",
        "Link Layer",
        "Network Layer",
        "Host",
        "Switch",
        "Router",
        "Frame",
        "Packet",
        "Datagram",
        "Hop-to-hop",
        "Layer 2",
        "Layer 3"
      ]
    },
    {
      "deck": "OSN_L20.pdf",
      "topics": [
        "Network Layer Fundamentals",
        "Addressing and Subnetting",
        "ARP and Link Layer Interaction",
        "Routing and Routers",
        "Routing Protocols (OSPF, BGP)",
        "IP Address Allocation (DHCP, static)",
        "Network Address Translation (NAT)",
        "Data Plane vs Control Plane",
        "Autonomous Systems and Internet Scalability"
      ],
      "key_concepts": [
        "Encapsulation hierarchy (Application→Transport→Network→Link→Physical)",
        "Subnetting and CIDR notation",
        "ARP table resolution and broadcast",
        "Routing table entries: connected, static, dynamic",
        "Forwarding vs Routing distinction",
        "OSPF link‑state algorithm (Dijkstra)",
        "BGP path‑vector protocol",
        "DHCP discover/offer/ack sequence",
        "NAT translation table and port mapping",
        "Port Address Translation (PAT)",
        "Data plane vs control plane functions",
        "Autonomous System (AS) concept",
        "IP address allocation by ISP and RIR",
        "IPv4 scarcity and NAT usage",
        "IPv6 128‑bit address space"
      ],
      "skills": [
        "Compute subnet masks and CIDR ranges",
        "Determine ARP resolution process",
        "Build and interpret routing tables",
        "Analyze static vs dynamic routing configurations",
        "Simulate DHCP lease process",
        "Explain NAT translation and PAT",
        "Compare OSPF and BGP routing",
        "Identify IP address allocation mechanisms",
        "Evaluate data plane vs control plane functions",
        "Design a simple network with routers and subnets"
      ],
      "important_terms": [
        "ARP",
        "DHCP",
        "NAT",
        "PAT",
        "OSPF",
        "BGP",
        "CIDR",
        "IPv4",
        "IPv6",
        "IP address",
        "subnet mask",
        "routing table",
        "forwarding",
        "routing",
        "link‑state",
        "path‑vector",
        "autonomous system",
        "RIR",
        "ICANN",
        "static route",
        "dynamic route",
        "interface",
        "gateway",
        "broadcast",
        "port",
        "TCP",
        "UDP",
        "encapsulation",
        "data plane",
        "control plane",
        "MAC address",
        "TTL"
      ]
    },
    {
      "deck": "OSN_L21.pdf",
      "topics": [
        "Persistence and Storage Fundamentals",
        "Hard Disk Hardware Architecture",
        "Disk Access Latency Components",
        "Disk Performance Analysis",
        "Disk Scheduling Algorithms",
        "RAID and Redundancy"
      ],
      "key_concepts": [
        "Hard disk geometry (sectors, tracks, platters)",
        "Rotational delay (latency)",
        "Seek time (arm movement)",
        "Transfer time (data throughput)",
        "Block vs sector granularity",
        "Track buffer cache",
        "Writeback vs writethrough policies",
        "Random vs sequential I/O workloads",
        "Disk scheduling strategies (SSTF, SCAN, C-SCAN, F-SCAN)",
        "Starvation in disk scheduling",
        "RAID basics (redundancy, performance)",
        "File system interaction with disk",
        "Direct Memory Access (DMA)",
        "Disk controller operations",
        "Capacity vs performance trade-offs",
        "Throughput vs latency metrics"
      ],
      "skills": [
        "Compute disk access latency components (seek, rotation, transfer)",
        "Analyze disk performance for random and sequential workloads",
        "Design and evaluate disk scheduling algorithms",
        "Simulate disk I/O with cache policies",
        "Interpret disk performance metrics (throughput, latency)",
        "Compare high-performance vs capacity-oriented disks",
        "Understand and explain RAID configurations",
        "Implement basic file system read/write flow",
        "Model disk I/O using DMA and controller interactions",
        "Assess impact of cache write policies on data integrity"
      ],
      "important_terms": [
        "HDD",
        "SSD",
        "Sector",
        "Block",
        "Track",
        "Platter",
        "RPM",
        "Seek",
        "Rotational Latency",
        "Transfer Rate",
        "DMA",
        "Cache",
        "Writeback",
        "Writethrough",
        "SSTF",
        "SCAN",
        "C-SCAN",
        "F-SCAN",
        "RAID",
        "File System",
        "Disk Controller",
        "I/O Scheduler",
        "Capacity",
        "Throughput",
        "Latency"
      ]
    },
    {
      "deck": "OSN_L22.pdf",
      "topics": [
        "RAID fundamentals",
        "RAID levels (0,1,4,5)",
        "Performance evaluation of RAID",
        "Reliability and fault tolerance",
        "Parity mechanisms and XOR",
        "Chunk size impact on I/O",
        "Small‑write problem and solutions",
        "Capacity calculations for RAID",
        "RAID implementation architecture"
      ],
      "key_concepts": [
        "Striping",
        "Mirroring",
        "Parity block",
        "XOR operation",
        "Additive parity",
        "Subtractive parity",
        "Rotating parity",
        "Chunk size",
        "I/O latency",
        "Steady‑state throughput",
        "Random vs sequential I/O",
        "Disk failure tolerance"
      ],
      "skills": [
        "Analyze RAID performance under different workloads",
        "Calculate capacity and throughput for RAID configurations",
        "Evaluate reliability of RAID levels",
        "Design RAID setups for specific requirements",
        "Implement parity calculation algorithms",
        "Troubleshoot small‑write bottlenecks",
        "Compare and contrast RAID levels",
        "Model I/O latency in RAID systems",
        "Simulate RAID operations",
        "Interpret performance metrics of RAID"
      ],
      "important_terms": [
        "RAID",
        "RAID 0",
        "RAID 1",
        "RAID 4",
        "RAID 5",
        "Striping",
        "Mirroring",
        "Parity",
        "XOR",
        "Chunk size",
        "Block",
        "Disk controller",
        "DMA",
        "Seek time",
        "Rotational delay",
        "Throughput",
        "Latency",
        "Fault tolerance",
        "Additive parity",
        "Subtractive parity",
        "Rotating parity",
        "Small‑write problem",
        "Steady‑state throughput",
        "Disk failure"
      ]
    },
    {
      "deck": "OSN_L23.pdf",
      "topics": [
        "Persistence: Files and Directories",
        "Virtualization of Storage",
        "File System Interface and System Calls",
        "Inode and Directory Structures",
        "File Operations and Access Methods",
        "Hard and Symbolic Links",
        "Mounting and File System Hierarchy",
        "Simple File System (VSFS) Design",
        "Metadata Management and Disk Organization"
      ],
      "key_concepts": [
        "File abstraction as linear byte array",
        "Inode as persistent metadata record",
        "Directory entries mapping names to i-nodes",
        "File descriptors and open flags (O_CREAT, O_WRONLY, O_TRUNC)",
        "lseek and SEEK_SET for random access",
        "fsync for immediate persistence",
        "Hard link creation and link count",
        "Symbolic link semantics and dangling references",
        "Mounting filesystems into directory tree",
        "Superblock storing layout metadata",
        "Bitmap for free/used block tracking",
        "Data region allocation for file contents",
        "Sequential vs random read/write behavior",
        "Buffer caching and write-back strategy",
        "File permissions and ownership"
      ],
      "skills": [
        "Use open/read/write/lseek/fsync system calls correctly",
        "Interpret file descriptor semantics and offsets",
        "Design on-disk data structures for a simple file system",
        "Implement inode allocation and bitmap management",
        "Create and manage hard and symbolic links",
        "Understand and perform filesystem mounting",
        "Analyze file metadata and permissions",
        "Simulate sequential and random file access patterns",
        "Evaluate effects of buffering on persistence",
        "Construct a superblock and directory hierarchy"
      ],
      "important_terms": [
        "inode",
        "i-node number",
        "file descriptor",
        "O_CREAT",
        "O_WRONLY",
        "O_TRUNC",
        "lseek",
        "SEEK_SET",
        "fsync",
        "hard link",
        "symbolic link",
        "mount",
        "superblock",
        "bitmap",
        "data region",
        "block allocation",
        "directory entry",
        "file system",
        "file permissions",
        "link count",
        "disk block",
        "buffer cache",
        "file hierarchy",
        "absolute pathname"
      ]
    },
    {
      "deck": "OSN_L24.pdf",
      "topics": [
        "File System Architecture & Access Flow",
        "Inode Structure & Metadata",
        "Block Addressing (Direct/Indirect/Multilevel)",
        "Directory Organization & Pathname Resolution",
        "Free Space Management (Bitmap & Free List)",
        "File Open/Read/Write Mechanics",
        "Open File Tables (Global & Per-Process)",
        "Caching & Buffering Strategies",
        "Disk I/O & DMA Operations",
        "File System Mounting & Superblock",
        "Performance Trade‑offs (Durability vs Speed)",
        "Implementation Design Choices"
      ],
      "key_concepts": [
        "Superblock",
        "Inode",
        "Direct Pointer",
        "Indirect Pointer",
        "Double Indirect Pointer",
        "Triple Indirect Pointer",
        "Directory Entry",
        "File Descriptor",
        "Open File Table",
        "Per‑Process File Table",
        "Bitmap Allocation",
        "Free List Allocation",
        "Caching (LRU)",
        "Write Buffering",
        "fsync",
        "Durability",
        "Performance Trade‑off",
        "DMA",
        "Disk Controller",
        "Block Size"
      ],
      "skills": [
        "Implement inode allocation and metadata handling",
        "Design directory entry format and pathname resolution",
        "Compute block offsets and address calculations",
        "Simulate file open/read/write system calls",
        "Analyze disk I/O cost for file operations",
        "Implement caching policies (LRU, write‑back)",
        "Create and manage free space bitmaps",
        "Evaluate durability vs performance trade‑offs",
        "Simulate file system mounting and superblock initialization",
        "Design efficient file system data structures"
      ],
      "important_terms": [
        "inode",
        "superblock",
        "direct pointer",
        "indirect pointer",
        "double indirect pointer",
        "triple indirect pointer",
        "directory entry",
        "file descriptor",
        "open file table",
        "per‑process file table",
        "bitmap",
        "free list",
        "DMA",
        "disk controller",
        "LRU",
        "write buffering",
        "fsync",
        "durability",
        "performance",
        "block size",
        "block address",
        "file system cache",
        "virtual memory",
        "page cache"
      ]
    },
    {
      "deck": "OSN_L25_revision.pdf",
      "topics": [
        "Process Virtualization & Scheduling",
        "Process State Management",
        "OS Networking Stack & Protocols",
        "OSI Model & Layered Communication",
        "Application Layer Protocols (HTTP, DNS)",
        "Transport Layer (TCP vs UDP)",
        "Memory Management (Segmentation, Paging, TLB)",
        "Concurrency & Synchronization (Locks, Semaphores, Producer‑Consumer)",
        "Network Layer (IP, Routing, DHCP, NAT)",
        "Data Link Layer (MAC, ARP)",
        "Physical Layer & Encapsulation",
        "Storage Systems (Disks, RAID, File Systems)"
      ],
      "key_concepts": [
        "Process Control Block (PCB)",
        "Scheduling Algorithms (SJF, RR, Priority)",
        "System Call Interface",
        "TCP Reliability (ACK, retransmission, flow control)",
        "UDP Characteristics (connectionless, low overhead)",
        "Paging & Page Table Entries",
        "Translation Lookaside Buffer (TLB)",
        "Semaphores & Mutexes",
        "Producer‑Consumer Problem",
        "Dynamic Routing (OSPF, BGP)",
        "DHCP Address Allocation",
        "NAT Translation Tables",
        "ARP Resolution & Cache TTL",
        "RAID Levels (0,1,5,6)",
        "Inode Structure & File System Traversal",
        "End‑to‑End Encapsulation",
        "De‑encapsulation",
        "Flow Control & Congestion Control",
        "Error Detection & Correction",
        "Disk Seek, Rotational Latency"
      ],
      "skills": [
        "Analyze process state transitions and scheduling decisions",
        "Design and evaluate scheduling policies for CPU and I/O",
        "Implement a system call handler in a kernel module",
        "Simulate TCP three‑way handshake and packet loss scenarios",
        "Build a paging simulator with TLB support",
        "Use semaphores to synchronize producer and consumer threads",
        "Configure a DHCP server and client in a network lab",
        "Set up NAT on a router and trace packet translation",
        "Resolve ARP requests in a simulated LAN",
        "Create a simple file system with inode and directory structures",
        "Compute RAID parity and recover data from failed disks",
        "Measure and optimize disk I/O performance"
      ],
      "important_terms": [
        "PCB",
        "SJF",
        "RR",
        "Priority Scheduling",
        "System Call",
        "TCP",
        "UDP",
        "ACK",
        "SYN",
        "Nagle",
        "Page Fault",
        "TLB",
        "Semaphore",
        "Mutex",
        "Producer‑Consumer",
        "OSPF",
        "BGP",
        "DHCP",
        "NAT",
        "ARP",
        "MAC Address",
        "IP Address",
        "IPv4",
        "IPv6",
        "RAID-5",
        "RAID-6",
        "Inode",
        "Routing Table",
        "ARP Cache",
        "TTL",
        "QoS",
        "Flow Control",
        "Congestion Control"
      ]
    }
  ],
  "learning_objectives": [
    "CO-1: Students will analyze the process lifecycle and scheduling decisions in the Xv6 operating system given a set of workload traces, achieving at least 90% accuracy in predicting turnaround time.",
    "CO-2: Students will design a multi‑level feedback queue scheduler that handles I/O blocking and priority inversion, given a mixed CPU‑I/O workload, and demonstrate a 20% reduction in average response time compared to a round‑robin baseline.",
    "CO-3: Students will implement a virtual memory paging simulator with TLB support, given a fixed page size and a sequence of memory accesses, and achieve a TLB hit rate of at least 85% while keeping memory usage within 10 % of the theoretical minimum.",
    "CO-4: Students will evaluate the performance impact of different disk scheduling algorithms (SSTF, SCAN, C‑SCAN) on a simulated HDD, given realistic seek and rotational latency parameters, and report a 15% improvement in average I/O latency over a first‑come‑first‑served schedule.",
    "CO-5: Students will compare and contrast TCP and UDP transport protocols by building client/server applications, given a network with packet loss and variable delay, and achieve ≥95% packet delivery success for TCP and ≥80% throughput for UDP under the specified conditions.",
    "CO-6: Students will design and implement a simple file system with inode, directory, and block allocation structures, given a block size of 4 KB and a maximum file count of 10,000, and demonstrate data integrity and a 10 % reduction in average file open latency compared to a naive linear search.",
    "CO-7: Students will analyze and mitigate deadlock scenarios in a multi‑threaded producer‑consumer system, given a set of resource allocation graphs and a concurrency bug taxonomy, and achieve a 100 % resolution rate with no starvation or livelock under the constraints."
  ]
}