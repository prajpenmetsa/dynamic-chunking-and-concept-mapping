{
  "course_title": "Operating Systems and Networks",
  "course_code": "CS3.301",
  "metadata": {
    "source": "All lecture slide decks (text-only)",
    "folder": "/Users/lakshmiprajnapenmetsa/Desktop/iiith/research/irel/honors/dynamic-chunking-and-concept-mapping/raw-data/osn_lecs",
    "framework": "SMART (Specific, Measurable, Achievable, Relevant, Time-bound)",
    "model": "gpt-oss:20b-cloud",
    "num_pdfs_found": 25,
    "num_decks_summarized": 25,
    "per_deck_text_truncation_chars": 45000,
    "note": "Per-deck prompts may truncate very long extracted text, but every PDF contributes via per-deck summaries."
  },
  "extraction_report": [
    {
      "deck": "OSN_L01.pdf",
      "extracted_chars": 10059,
      "status": "summarized"
    },
    {
      "deck": "OSN_L02.pdf",
      "extracted_chars": 5474,
      "status": "summarized"
    },
    {
      "deck": "OSN_L03.pdf",
      "extracted_chars": 13324,
      "status": "summarized"
    },
    {
      "deck": "OSN_L04.pdf",
      "extracted_chars": 9910,
      "status": "summarized"
    },
    {
      "deck": "OSN_L05.pdf",
      "extracted_chars": 8930,
      "status": "summarized"
    },
    {
      "deck": "OSN_L06.pdf",
      "extracted_chars": 10774,
      "status": "summarized"
    },
    {
      "deck": "OSN_L07.pdf",
      "extracted_chars": 7832,
      "status": "summarized"
    },
    {
      "deck": "OSN_L08.pdf",
      "extracted_chars": 5554,
      "status": "summarized"
    },
    {
      "deck": "OSN_L09.pdf",
      "extracted_chars": 13821,
      "status": "summarized"
    },
    {
      "deck": "OSN_L10.pdf",
      "extracted_chars": 11824,
      "status": "summarized"
    },
    {
      "deck": "OSN_L11.pdf",
      "extracted_chars": 11282,
      "status": "summarized"
    },
    {
      "deck": "OSN_L12.pdf",
      "extracted_chars": 10542,
      "status": "summarized"
    },
    {
      "deck": "OSN_L13.pdf",
      "extracted_chars": 11592,
      "status": "summarized"
    },
    {
      "deck": "OSN_L14.pdf",
      "extracted_chars": 6345,
      "status": "summarized"
    },
    {
      "deck": "OSN_L15.pdf",
      "extracted_chars": 8878,
      "status": "summarized"
    },
    {
      "deck": "OSN_L16.pdf",
      "extracted_chars": 6799,
      "status": "summarized"
    },
    {
      "deck": "OSN_L17.pdf",
      "extracted_chars": 6209,
      "status": "summarized"
    },
    {
      "deck": "OSN_L18.pdf",
      "extracted_chars": 7122,
      "status": "summarized"
    },
    {
      "deck": "OSN_L19.pdf",
      "extracted_chars": 5699,
      "status": "summarized"
    },
    {
      "deck": "OSN_L20.pdf",
      "extracted_chars": 9810,
      "status": "summarized"
    },
    {
      "deck": "OSN_L21.pdf",
      "extracted_chars": 9782,
      "status": "summarized"
    },
    {
      "deck": "OSN_L22.pdf",
      "extracted_chars": 10477,
      "status": "summarized"
    },
    {
      "deck": "OSN_L23.pdf",
      "extracted_chars": 10985,
      "status": "summarized"
    },
    {
      "deck": "OSN_L24.pdf",
      "extracted_chars": 10107,
      "status": "summarized"
    },
    {
      "deck": "OSN_L25_revision.pdf",
      "extracted_chars": 13093,
      "status": "summarized"
    }
  ],
  "deck_summaries": [
    {
      "deck": "OSN_L01.pdf",
      "topics": [
        "Operating System Fundamentals",
        "OS History and Evolution",
        "OS Abstraction and Middleware Role",
        "Process and Memory Management",
        "Virtualization and Concurrency",
        "Persistence and File Systems",
        "Networking Fundamentals",
        "OS Design Goals and Principles",
        "Course Structure and Assessment"
      ],
      "key_concepts": [
        "Middleware abstraction",
        "Process isolation",
        "Virtual memory",
        "Paging",
        "Segmentation",
        "Context switching",
        "Deadlock",
        "Scheduling algorithms",
        "File system hierarchy",
        "Device drivers",
        "I/O buffering",
        "Network sockets",
        "TCP/IP stack",
        "DNS resolution",
        "Concurrency primitives",
        "Memory protection",
        "Resource allocation",
        "Disk scheduling",
        "Network protocols"
      ],
      "skills": [
        "Analyze process scheduling policies",
        "Design a basic virtual memory manager",
        "Implement a simple file system interface",
        "Debug concurrency issues in multithreaded programs",
        "Use sockets to build client-server communication",
        "Evaluate OS performance trade-offs",
        "Model deadlock scenarios and propose solutions",
        "Configure and use device drivers",
        "Interpret system call traces",
        "Apply security principles to OS design",
        "Optimize I/O buffering strategies"
      ],
      "important_terms": [
        "Operating System",
        "Kernel",
        "User space",
        "System call",
        "Process",
        "Thread",
        "Virtual memory",
        "Paging",
        "Context switch",
        "Scheduler",
        "Deadlock",
        "Mutex",
        "Semaphore",
        "File system",
        "Device driver",
        "Buffer cache",
        "TCP/IP",
        "Socket",
        "DNS",
        "ARPANET"
      ]
    },
    {
      "deck": "OSN_L02.pdf",
      "topics": [
        "Process fundamentals",
        "CPU virtualization",
        "Process lifecycle",
        "Process states",
        "Process creation",
        "Process control block (PCB)",
        "Scheduling and context switching",
        "Hardware-software interaction",
        "CPU pipeline & superscalar execution",
        "Operating system data structures",
        "Xv6 operating system example"
      ],
      "key_concepts": [
        "Process vs Program",
        "Virtualization of CPU",
        "Context switch",
        "Scheduler policies",
        "Process Control Block (PCB)",
        "Address space and memory image",
        "Registers (PC, SP, PSW)",
        "I/O blocking and waiting",
        "Lazy loading of executable",
        "Process states (Running, Ready, Blocked)",
        "Ready queue and blocked queue",
        "Process ID (PID)",
        "Stack and Heap management",
        "File descriptors",
        "Superscalar pipeline stages",
        "Fetch‑Decode‑Execute cycle",
        "Process creation steps",
        "Memory mapping",
        "Process metadata storage",
        "CPU scheduling algorithms"
      ],
      "skills": [
        "Identify and explain process states and transitions",
        "Describe the steps involved in process creation",
        "Explain how context switching preserves CPU state",
        "Analyze the impact of I/O blocking on scheduling",
        "Design a PCB data structure",
        "Compare single‑core and multi‑core scheduling strategies",
        "Interpret the role of CPU registers in execution",
        "Explain lazy loading and its benefits",
        "Describe superscalar pipeline operation",
        "Understand the Xv6 process implementation"
      ],
      "important_terms": [
        "Process",
        "Program",
        "Virtualization",
        "Context Switch",
        "Scheduler",
        "PCB",
        "PID",
        "Address Space",
        "Stack",
        "Heap",
        "Registers",
        "PC",
        "SP",
        "PSW",
        "I/O",
        "Blocking",
        "Ready",
        "Running",
        "Lazy Loading",
        "Superscalar",
        "Pipeline",
        "Xv6",
        "OS",
        "CPU",
        "Memory",
        "Disk",
        "File Descriptor"
      ]
    },
    {
      "deck": "OSN_L03.pdf",
      "topics": [
        "Process Virtualization and API",
        "System Calls and OS Interfaces",
        "Process Creation and Management (fork, exec, wait, exit)",
        "User vs Kernel Modes and Limited Direct Execution",
        "System Call Mechanism (trap, IDT)",
        "Process Switching and Scheduling (preemptive vs cooperative)",
        "Context Switching and Scheduler Design",
        "Shell Operation and I/O Redirection",
        "Challenges in Process Virtualization",
        "OS Boot and LDE Protocol"
      ],
      "key_concepts": [
        "fork",
        "exec",
        "wait",
        "exit",
        "system call",
        "trap instruction",
        "IDT (Interrupt Descriptor Table)",
        "user mode",
        "kernel mode",
        "Limited Direct Execution (LDE)",
        "context switch",
        "timer interrupt",
        "scheduler",
        "process table",
        "process state",
        "privilege level",
        "interrupt handling",
        "return-from-trap",
        "shell fork-exec pattern",
        "I/O redirection"
      ],
      "skills": [
        "simulate fork/exec behavior",
        "implement a system call handler",
        "design a context switch routine",
        "analyze preemptive vs cooperative scheduling",
        "simulate timer interrupt and context switching",
        "trace process state transitions",
        "debug zombie and orphan processes",
        "write shell command parsing logic",
        "understand privilege escalation and protection",
        "implement LDE protocol flow"
      ],
      "important_terms": [
        "fork",
        "exec",
        "wait",
        "exit",
        "system call",
        "trap",
        "IDT",
        "LDE",
        "user mode",
        "kernel mode",
        "context switch",
        "scheduler",
        "timer interrupt",
        "process table",
        "process state",
        "privilege level",
        "interrupt",
        "exception",
        "syscall handler",
        "return-from-trap",
        "shell",
        "I/O redirection",
        "zombie process",
        "orphan process",
        "init process",
        "POSIX",
        "privileged instruction"
      ]
    },
    {
      "deck": "OSN_L04.pdf",
      "topics": [
        "User vs Kernel Mode & Privilege Switching",
        "TRAP Instruction and System Calls",
        "Interrupts and Timer‑Based Context Switching",
        "Context Switch Mechanics",
        "Scheduling Policies and Metrics",
        "Workload Assumptions & Performance Evaluation",
        "Cooperative vs Preemptive Scheduling",
        "LDE Protocol (Boot & Run Phases)"
      ],
      "key_concepts": [
        "TRAP instruction",
        "Return‑from‑trap",
        "Interrupt Descriptor Table (IDT)",
        "Trap table",
        "Kernel stack",
        "User stack",
        "Timer interrupt",
        "Context switch routine",
        "Scheduler",
        "First‑Come‑First‑Serve (FCFS)",
        "Shortest‑Job‑First (SJF)",
        "Shortest‑Time‑to‑Completion‑First (STCF)",
        "Preemption",
        "Cooperative scheduling",
        "LDE protocol steps",
        "System call handling",
        "Turnaround time",
        "Fairness index",
        "Convoy effect"
      ],
      "skills": [
        "Explain privilege mode transitions",
        "Describe how TRAP instruction triggers kernel entry",
        "Implement a basic context switch routine",
        "Analyze scheduling metrics such as turnaround and fairness",
        "Compare cooperative and preemptive scheduling models",
        "Design a scheduler policy for a given workload",
        "Explain the LDE protocol during boot and run phases",
        "Evaluate the impact of timer interrupts on CPU utilization",
        "Identify causes of convoy effect in FCFS",
        "Apply SJF/STCF to sample job sets"
      ],
      "important_terms": [
        "TRAP",
        "Return‑from‑trap",
        "IDT",
        "Trap table",
        "Kernel stack",
        "User stack",
        "Interrupt",
        "Timer interrupt",
        "Context switch",
        "Scheduler",
        "FCFS",
        "SJF",
        "STCF",
        "Preemption",
        "Cooperative scheduling",
        "LDE protocol",
        "System call",
        "Privilege mode",
        "Kernel mode",
        "User mode",
        "Turnaround time",
        "Fairness index",
        "Convoy effect"
      ]
    },
    {
      "deck": "OSN_L05.pdf",
      "topics": [
        "Process Scheduling Fundamentals",
        "Time Slicing and Context Switching",
        "I/O Handling and Blocking",
        "Priority-Based Scheduling",
        "Multi‑Level Feedback Queue (MLFQ) Design",
        "Fairness, Starvation, and Scheduler Gaming",
        "Scheduler Tuning and Parameter Selection",
        "Inter‑Process Communication Basics",
        "OS Role in Networked Process Communication"
      ],
      "key_concepts": [
        "Round Robin (RR) scheduling",
        "Time slice and timer interrupts",
        "Context switch overhead",
        "Turnaround time vs. response time",
        "Shortest Job First (SJF)",
        "Shortest Time to Completion First (STCF)",
        "Priority scheduling with dynamic priorities",
        "Multi‑Level Feedback Queue (MLFQ) mechanics",
        "Priority boost to prevent starvation",
        "Starvation and gaming of the scheduler",
        "I/O blocking and interrupt‑driven state changes",
        "Process states: ready, running, blocked",
        "CPU‑bound vs. I/O‑bound processes",
        "Interactive vs. non‑interactive workloads",
        "Basic inter‑process communication (IPC) over networks"
      ],
      "skills": [
        "Analyze and compute turnaround and response times for given job traces",
        "Design and tune Round Robin and MLFQ parameters",
        "Implement a simple Round Robin scheduler in code",
        "Simulate process state transitions with I/O blocking",
        "Evaluate fairness vs. performance trade‑offs in scheduling policies",
        "Identify and mitigate starvation and scheduler gaming scenarios",
        "Model priority boost intervals and their impact",
        "Design basic IPC mechanisms for cross‑machine communication",
        "Use OS networking primitives to transfer messages between processes"
      ],
      "important_terms": [
        "RR",
        "SJF",
        "STCF",
        "MLFQ",
        "Priority Boost",
        "Context Switch",
        "Time Slice",
        "Turnaround Time",
        "Response Time",
        "Starvation",
        "Gaming",
        "I/O Blocking",
        "Interrupt",
        "Ready Queue",
        "Blocked Queue",
        "CPU‑bound",
        "I/O‑bound",
        "Interactive",
        "Non‑Interactive",
        "Process State",
        "Scheduler",
        "Priority",
        "IPC",
        "Network Stack",
        "Message Passing"
      ]
    },
    {
      "deck": "OSN_L06.pdf",
      "topics": [
        "Network Architecture and Components",
        "IP Addressing and Addressing Schemes",
        "OSI Layering and Protocols",
        "Data Link and Physical Layer Concepts",
        "Switching vs Routing Mechanisms",
        "Transport Layer Protocols",
        "Application Layer Protocols",
        "Encapsulation and Protocol Stacks"
      ],
      "key_concepts": [
        "OSI seven-layer model",
        "TCP/IP four-layer model",
        "Encapsulation and decapsulation process",
        "IPv4 addressing and subnetting",
        "MAC addressing and ARP",
        "Switching operations and VLANs",
        "Routing principles and forwarding tables",
        "TCP reliability features (handshake, flow control, error correction)",
        "UDP connectionless communication",
        "ICMP error reporting",
        "Port number allocation (well-known, registered, dynamic)",
        "Error detection and correction techniques"
      ],
      "skills": [
        "Analyze and explain network layering concepts",
        "Implement basic TCP/UDP socket communication in code",
        "Configure and troubleshoot IP addressing on hosts",
        "Simulate packet forwarding in a router or switch",
        "Explain the encapsulation process across layers",
        "Compare switching and routing mechanisms in practice",
        "Interpret and dissect network protocol headers",
        "Use port numbers to identify services and applications",
        "Diagnose network connectivity and routing issues",
        "Apply OSI model to real-world networking scenarios"
      ],
      "important_terms": [
        "OSI",
        "TCP/IP",
        "IP",
        "MAC",
        "ARP",
        "ICMP",
        "UDP",
        "TCP",
        "Switch",
        "Router",
        "Hub",
        "Repeater",
        "Bridge",
        "LAN",
        "WAN",
        "MAN",
        "PAN",
        "VLAN",
        "Ethernet",
        "802.11",
        "HTTP",
        "SMTP",
        "DNS",
        "Port",
        "Socket"
      ]
    },
    {
      "deck": "OSN_L07.pdf",
      "topics": [
        "Transport Layer Overview",
        "Socket API and System Calls",
        "Port Addressing and Types",
        "Multiplexing & Demultiplexing",
        "Connection-Oriented vs Connectionless",
        "TCP vs UDP Features",
        "Reliability, Flow & Congestion Control",
        "UDP Header & Checksum",
        "TCP Connection Establishment",
        "OS Interaction & Context Switches",
        "Link Types (Full/Half/Simplex)",
        "Layered Network Model"
      ],
      "key_concepts": [
        "Transport layer services (stream vs datagram)",
        "Socket creation and lifecycle (socket, bind, listen, accept, connect, send/recv, close)",
        "Port numbers: well-known, dynamic, and their role in addressing",
        "Multiplexing at sender and demultiplexing at receiver using 4-tuple (TCP) or 2-tuple (UDP)",
        "TCP reliability mechanisms: ACKs, retransmission, ordering",
        "TCP flow control via sliding window",
        "TCP congestion control basics",
        "UDP header structure and 8‑byte length",
        "UDP checksum computation using 1’s complement and pseudo‑header",
        "TCP header size (~20 bytes) and optional fields",
        "TCP three‑way handshake for connection establishment",
        "Blocking system calls trigger context switches",
        "Full‑duplex, half‑duplex, and simplex link characteristics",
        "Layered model: application → transport → internet → link"
      ],
      "skills": [
        "Implement a TCP client/server using socket API",
        "Bind sockets to well‑known and dynamic ports",
        "Use listen/accept to handle multiple connections",
        "Compute and verify UDP checksums",
        "Explain how TCP achieves reliability and flow control",
        "Compare overhead of TCP vs UDP headers",
        "Identify link types and their impact on data flow",
        "Map application messages to transport segments and network packets",
        "Analyze blocking system calls and context switch behavior",
        "Understand and describe the TCP three‑way handshake"
      ],
      "important_terms": [
        "Transport Layer",
        "Socket API",
        "Port Number",
        "Well‑known Port",
        "Ephemeral Port",
        "TCP",
        "UDP",
        "4‑tuple",
        "2‑tuple",
        "ACK",
        "Checksum",
        "Three‑way Handshake",
        "Flow Control",
        "Congestion Control",
        "Full Duplex",
        "Half Duplex",
        "Simplex",
        "System Call",
        "Context Switch",
        "Pseudo Header"
      ]
    },
    {
      "deck": "OSN_L08.pdf",
      "topics": [
        "TCP fundamentals and header structure",
        "Reliability mechanisms (ACK, sequence numbers, retransmission)",
        "Flow control and congestion control basics",
        "Connection establishment and termination (3‑way handshake, FIN, RST)",
        "Memory virtualization and virtual memory concepts",
        "Address translation and MMU"
      ],
      "key_concepts": [
        "TCP header fields (source/dest port, seq/ack numbers, flags, window)",
        "Sequence number tracking of sent bytes",
        "Acknowledgment number tracking of expected bytes",
        "Retransmission timeout (RTT estimation, EWMA)",
        "Delayed ACK strategy",
        "Flow control via receive window",
        "3‑way handshake sequence (SYN, SYN‑ACK, ACK)",
        "Connection termination with FIN and RST flags",
        "Virtual address space abstraction",
        "Physical memory mapping",
        "Address translation by MMU",
        "Process isolation in virtual memory"
      ],
      "skills": [
        "Analyze and interpret TCP packet headers",
        "Compute RTT and set retransmission timeout",
        "Explain the 3‑way handshake and connection teardown",
        "Describe how delayed ACK improves throughput",
        "Illustrate flow control using the receive window",
        "Explain memory virtualization and its benefits",
        "Demonstrate address translation from virtual to physical addresses",
        "Discuss process isolation and protection mechanisms",
        "Evaluate the impact of window size on throughput"
      ],
      "important_terms": [
        "TCP",
        "SYN",
        "ACK",
        "FIN",
        "RST",
        "Sequence number",
        "Acknowledgment number",
        "Window size",
        "Flow control",
        "Congestion control",
        "RTT",
        "Retransmission timeout",
        "Delayed ACK",
        "3‑way handshake",
        "Virtual memory",
        "Virtual address",
        "Physical address",
        "MMU",
        "Page table",
        "Process isolation",
        "Buffer"
      ]
    },
    {
      "deck": "OSN_L09.pdf",
      "topics": [
        "Virtualization goals and principles",
        "Memory allocation APIs and common pitfalls",
        "Dynamic relocation with base/bounds registers",
        "Segmentation and segment registers",
        "Address translation and bounds checking",
        "Fragmentation and compaction",
        "Hardware support and protection mechanisms",
        "Coarse‑ vs fine‑grained segmentation",
        "Context switching and segment management"
      ],
      "key_concepts": [
        "Transparency, Efficiency, and Protection in virtualization",
        "Virtual Address Space (VAS) vs Physical Address Space (PAS)",
        "Base register + bounds register for dynamic relocation",
        "Segmented memory model (code, heap, stack)",
        "Segment registers and segment tables",
        "Bounds checking and protection bits",
        "External fragmentation in segmented memory",
        "Memory compaction to eliminate fragmentation",
        "Implicit vs explicit segment identification",
        "Stack growth direction handling",
        "Memory allocation system calls: brk/sbrk, mmap",
        "Library allocation functions: malloc, free, calloc, realloc",
        "Common memory errors: leaks, dangling pointers, double free",
        "Debugging tools: valgrind, purify",
        "Code sharing and read‑only segments"
      ],
      "skills": [
        "Identify and diagnose common malloc/free errors",
        "Implement dynamic relocation using base/bounds registers",
        "Design a segmentation scheme for a process",
        "Simulate virtual-to-physical address translation",
        "Analyze and mitigate external fragmentation",
        "Implement memory compaction techniques",
        "Use MMU registers to enforce protection",
        "Compare coarse‑ and fine‑grained segmentation strategies",
        "Manage segment registers during context switches",
        "Apply debugging tools to detect memory misuse"
      ],
      "important_terms": [
        "OS",
        "Virtual Memory",
        "Physical Memory",
        "Virtual Address",
        "Physical Address",
        "Base Register",
        "Bounds Register",
        "MMU",
        "Segmentation",
        "Segment Register",
        "Segment Table",
        "External Fragmentation",
        "Compaction",
        "Code Sharing",
        "Protection Bits",
        "Coarse‑grained Segmentation",
        "Fine‑grained Segmentation",
        "Dynamic Relocation",
        "malloc",
        "free",
        "calloc",
        "realloc",
        "mmap",
        "brk",
        "sbrk",
        "garbage collector",
        "valgrind",
        "dangling pointer",
        "double free",
        "memory leak"
      ]
    },
    {
      "deck": "OSN_L10.pdf",
      "topics": [
        "Memory Virtualization Overview",
        "Segmentation and Fragmentation",
        "Paging Fundamentals",
        "Page Table Structure and Translation",
        "TLB and Address Translation Acceleration",
        "TLB Miss Handling (Hardware vs Software)",
        "Context Switching and ASID Management",
        "Page Sharing and Protection"
      ],
      "key_concepts": [
        "Segmentation (coarse vs fine-grained)",
        "External fragmentation and compaction",
        "Paging (fixed-size pages)",
        "Virtual vs Physical address spaces",
        "Page tables and Page Table Entries (PTEs)",
        "VPN and PFN mapping",
        "PTBR (Page Table Base Register)",
        "TLB (Translation Lookaside Buffer)",
        "TLB miss handling strategies",
        "ASID (Address Space Identifier)",
        "Page sharing across processes",
        "Protection bits and access rights",
        "Valid, Present, Dirty, Reference bits"
      ],
      "skills": [
        "Analyze segmentation vs paging trade-offs",
        "Compute page table size for given page size and address space",
        "Simulate virtual-to-physical address translation",
        "Implement TLB lookup and miss handling",
        "Design efficient page allocation and compaction strategies",
        "Evaluate TLB hit rates and locality effects",
        "Explain ASID usage in context switches",
        "Discuss page sharing and protection mechanisms"
      ],
      "important_terms": [
        "Segmentation",
        "Coarse-grained",
        "Fine-grained",
        "External fragmentation",
        "Compaction",
        "Paging",
        "Virtual address",
        "Physical address",
        "Page table",
        "Page Table Entry (PTE)",
        "VPN",
        "PFN",
        "PTBR",
        "TLB",
        "Translation Lookaside Buffer",
        "ASID",
        "Valid bit",
        "Present bit",
        "Dirty bit",
        "Reference bit",
        "Protection bit",
        "Memory Management Unit (MMU)",
        "Page fault",
        "Spatial locality",
        "Temporal locality"
      ]
    },
    {
      "deck": "OSN_L11.pdf",
      "topics": [
        "Memory Virtualization & Paging",
        "TLB Architecture & Miss Handling",
        "Address Translation & Page Table Structures",
        "Context Switching & ASID Management",
        "Page Size Trade-offs & Fragmentation",
        "Hybrid Paging & Segmentation",
        "Multi‑Level Page Tables",
        "Inverted Page Tables",
        "Swap Space & Page Faults"
      ],
      "key_concepts": [
        "TLB (Translation Look‑aside Buffer)",
        "Virtual Page Number (VPN)",
        "Physical Frame Number (PFN)",
        "Page Table Entry (PTE) flags: Valid, Protection, Dirty",
        "Page Directory & Multi‑Level Page Tables",
        "Address Space Identifier (ASID)",
        "Context Switch TLB Flushing vs ASID",
        "Page Size Effects on Internal Fragmentation",
        "Linear vs Multi‑Level Page Table Memory Overhead",
        "Hybrid Paging + Segmentation Design",
        "Page Fault Handling & Swap Space",
        "Hardware vs Software TLB Miss Handling",
        "Base & Bound Registers in Segmentation",
        "Page Directory Base Register (PDBR)",
        "Inverted Page Table Concept"
      ],
      "skills": [
        "Compute TLB hit/miss patterns and hit rates",
        "Design page tables for a given virtual address space",
        "Implement a TLB miss handler (hardware/software)",
        "Explain ASID usage to avoid TLB flushes",
        "Compare memory overhead of linear vs multi‑level page tables",
        "Analyze page size trade‑offs and fragmentation",
        "Simulate page fault handling and swap usage",
        "Describe hybrid paging‑segmentation architecture",
        "Evaluate benefits of inverted page tables",
        "Construct multi‑level page table lookup sequences"
      ],
      "important_terms": [
        "TLB",
        "VPN",
        "PFN",
        "PTE",
        "ASID",
        "Page Directory",
        "Page Frame",
        "Page Size",
        "Offset",
        "Valid Bit",
        "Protection Bits",
        "Dirty Bit",
        "Page Fault",
        "Swap Space",
        "Segmentation",
        "Virtual Address",
        "Physical Address",
        "Memory Virtualization",
        "Internal Fragmentation",
        "External Fragmentation",
        "Linear Page Table",
        "Multi‑Level Page Table",
        "Inverted Page Table",
        "Base Register",
        "Bound Register",
        "PDBR",
        "MMU"
      ]
    },
    {
      "deck": "OSN_L12.pdf",
      "topics": [
        "Virtual memory fundamentals",
        "Address translation and multi‑level page tables",
        "Swap space and demand paging",
        "Page fault handling",
        "Page replacement algorithms",
        "Hardware support and page table bits",
        "Thrashing and admission control"
      ],
      "key_concepts": [
        "Paging",
        "Multi‑level page tables",
        "Swap space",
        "Page fault",
        "Page fault handler",
        "Present bit",
        "Accessed bit",
        "Dirty bit",
        "Optimal (MIN) replacement",
        "FIFO replacement",
        "LRU replacement",
        "Random replacement",
        "Belady’s anomaly",
        "Clock algorithm",
        "Thrashing",
        "Admission control",
        "Demand paging",
        "Cold miss"
      ],
      "skills": [
        "Analyze page fault scenarios and trace fault handling",
        "Design and configure swap space usage",
        "Implement a page fault handler simulation",
        "Evaluate and compare page replacement algorithms",
        "Use TLB and page table bits to optimize memory access",
        "Simulate thrashing and measure system performance",
        "Explain Belady’s anomaly with example traces",
        "Implement LRU using accessed and dirty bits",
        "Apply admission control to mitigate thrashing"
      ],
      "important_terms": [
        "Virtual address",
        "Physical address",
        "VPN (Virtual Page Number)",
        "Offset",
        "PFN (Page Frame Number)",
        "PTE (Page Table Entry)",
        "TLB (Translation Lookaside Buffer)",
        "Swap space",
        "Page fault",
        "Present bit",
        "Accessed bit",
        "Dirty bit",
        "Page replacement",
        "Optimal (MIN)",
        "FIFO",
        "LRU",
        "Random",
        "Belady’s anomaly",
        "Clock algorithm",
        "Thrashing",
        "Admission control",
        "Demand paging",
        "Cold miss"
      ]
    },
    {
      "deck": "OSN_L13.pdf",
      "topics": [
        "Network Application Architectures (Client‑Server vs P2P)",
        "Application Layer Protocols",
        "HTTP Protocol Details (request/response, methods, status codes)",
        "HTTP Connection Management (persistent vs non‑persistent, HTTP/2/3)",
        "State Management in HTTP (Cookies, Sessions)",
        "Web Caching and Content Delivery Networks",
        "Domain Name System (DNS) Fundamentals",
        "DNS Resolution and Record Types"
      ],
      "key_concepts": [
        "Client‑Server vs P2P architecture",
        "Socket interface for network communication",
        "HTTP request line, headers, and supported methods",
        "HTTP response status line and headers",
        "Persistent vs non‑persistent HTTP connections",
        "HTTP cookies and session tracking",
        "Conditional GET and Last‑Modified header",
        "Web caching mechanisms and cache hit/miss",
        "CDN deployment strategies (Deep vs Bring Home)",
        "DNS hierarchical distributed database",
        "DNS resource record types (A, CNAME, MX, NS)",
        "DNS TTL and caching behavior"
      ],
      "skills": [
        "Implement a simple HTTP client using sockets",
        "Parse HTTP request and response headers",
        "Design a basic web cache with conditional GET support",
        "Configure and explain DNS record types",
        "Compare client‑server and P2P application designs",
        "Analyze HTTP connection performance (persistent vs non‑persistent)",
        "Use cookies to maintain session state in a web application",
        "Evaluate CDN placement strategies for latency reduction",
        "Understand and explain the DNS resolution process"
      ],
      "important_terms": [
        "HTTP",
        "TCP",
        "UDP",
        "IP",
        "DNS",
        "A record",
        "CNAME",
        "MX record",
        "NS record",
        "TTL",
        "port 80",
        "port 53",
        "BIND",
        "socket",
        "cookies",
        "cache",
        "conditional GET",
        "CDN",
        "persistent connection",
        "non‑persistent connection"
      ]
    },
    {
      "deck": "OSN_L14.pdf",
      "topics": [
        "Process fundamentals",
        "Thread basics",
        "Memory model: Process vs Thread",
        "Concurrency vs Parallelism",
        "Thread scheduling",
        "Thread creation APIs",
        "Shared data & race conditions",
        "Kernel vs User threads"
      ],
      "key_concepts": [
        "Process",
        "Thread",
        "Address space sharing",
        "Copy‑on‑Write (CoW)",
        "Program Counter (PC)",
        "Stack Pointer (SP)",
        "Thread Control Block (TCB)",
        "Process Control Block (PCB)",
        "Kernel thread",
        "User thread",
        "POSIX threads",
        "pthread_create",
        "Scheduling",
        "Concurrency",
        "Parallelism",
        "Race condition"
      ],
      "skills": [
        "Explain process vs thread memory models",
        "Implement thread creation with pthread_create",
        "Analyze thread scheduling and context switches",
        "Identify and mitigate race conditions in shared data",
        "Distinguish concurrency from parallelism",
        "Differentiate kernel and user threads",
        "Use fork and exec semantics",
        "Evaluate non‑determinism in multithreaded programs",
        "Design thread‑safe code"
      ],
      "important_terms": [
        "Process",
        "Thread",
        "PC",
        "SP",
        "Address space",
        "Page table",
        "Copy‑on‑Write",
        "Fork",
        "Exec",
        "IPC",
        "Kernel thread",
        "User thread",
        "POSIX threads",
        "pthread_create",
        "TCB",
        "PCB",
        "Scheduling",
        "Concurrency",
        "Parallelism",
        "Race condition",
        "Context switch",
        "Stack",
        "Heap",
        "Global variable",
        "Non‑determinism"
      ]
    },
    {
      "deck": "OSN_L15.pdf",
      "topics": [
        "Concurrency Fundamentals",
        "Race Conditions & Critical Sections",
        "Mutual Exclusion & Atomicity",
        "Lock Primitives & Hardware Support",
        "Spin Locks & Ticket Locks",
        "Fairness, Starvation & Performance"
      ],
      "key_concepts": [
        "Race Condition",
        "Critical Section",
        "Mutual Exclusion",
        "Atomicity",
        "Lock/Unlock Mechanism",
        "Test‑and‑Set",
        "Compare‑and‑Swap",
        "Load‑Linked/Store‑Conditional",
        "Fetch‑and‑Add",
        "Spin Lock",
        "Ticket Lock",
        "Fairness Guarantee",
        "Starvation Avoidance",
        "Interrupt Disabling",
        "Hardware Atomic Primitives"
      ],
      "skills": [
        "Analyze race conditions in shared data",
        "Design critical sections with proper locking",
        "Implement spin locks using test‑and‑set",
        "Implement ticket locks with fetch‑and‑add",
        "Evaluate lock fairness and potential starvation",
        "Assess performance overhead of different lock types",
        "Understand and use hardware atomic primitives",
        "Debug concurrent programs for synchronization bugs",
        "Reason about thread scheduling and interrupt handling",
        "Apply mutual exclusion in multi‑processor environments"
      ],
      "important_terms": [
        "concurrency",
        "race condition",
        "critical section",
        "mutual exclusion",
        "atomicity",
        "lock",
        "unlock",
        "test‑and‑set",
        "compare‑and‑swap",
        "load‑linked",
        "store‑conditional",
        "fetch‑and‑add",
        "spin lock",
        "ticket lock",
        "fairness",
        "starvation",
        "interrupt",
        "preemption",
        "atomic exchange",
        "hardware primitive",
        "OS scheduler",
        "thread",
        "shared variable",
        "atomic operation"
      ]
    },
    {
      "deck": "OSN_L16.pdf",
      "topics": [
        "Spin Locks & Ticket Locks",
        "OS Primitives for Yielding & Sleeping",
        "Condition Variables",
        "Parent-Child Synchronization (join)",
        "Producer‑Consumer / Bounded Buffer",
        "Multiple Producers/Consumers",
        "Condition Variable Design Patterns",
        "Semaphores as Unified Mechanism"
      ],
      "key_concepts": [
        "Ticket lock using fetch‑and‑add",
        "Spin lock inefficiency and starvation",
        "OS yield() system call",
        "park()/unpark() for sleeping threads",
        "Condition variable wait() and signal()",
        "Using state variable with while loop",
        "Parent join implementation with condition variable",
        "Two condition variables (empty/fill) for bounded buffer",
        "Buffer indexing with fill and use counters",
        "Semaphore as Dijkstra’s solution",
        "Bounded buffer problem definition",
        "Producer‑consumer synchronization patterns",
        "Race condition prevention with locks",
        "Atomicity of critical section access",
        "Spinning vs sleeping trade‑offs",
        "Yielding vs park for CPU reuse",
        "Condition variable wake‑up semantics",
        "Semaphore counting mechanism",
        "Producer‑consumer with array buffer"
      ],
      "skills": [
        "Implement ticket lock with fetch‑and‑add",
        "Use yield() to avoid busy‑waiting",
        "Design park/unpark based sleep queues",
        "Create and use condition variables with wait/signal",
        "Implement join using condition variable and state flag",
        "Solve producer‑consumer with single and multiple threads",
        "Apply two‑condition‑variable pattern for bounded buffer",
        "Replace locks and condition variables with semaphores",
        "Analyze and prevent starvation in spin locks",
        "Debug race conditions in shared state updates",
        "Use while loop to guard condition variable waits",
        "Evaluate performance trade‑offs between spinning and sleeping",
        "Implement bounded buffer with array and indexing",
        "Understand atomic primitives in OS context",
        "Design synchronization for parent‑child thread relationships"
      ],
      "important_terms": [
        "ticket lock",
        "fetch‑and‑add",
        "spin lock",
        "yield",
        "park",
        "unpark",
        "condition variable",
        "wait",
        "signal",
        "join",
        "state variable",
        "while loop",
        "semaphore",
        "Dijkstra",
        "bounded buffer",
        "producer",
        "consumer",
        "critical section",
        "atomicity",
        "starvation",
        "race condition"
      ]
    },
    {
      "deck": "OSN_L17.pdf",
      "topics": [
        "Concurrency Primitives",
        "Producer‑Consumer & Bounded Buffer",
        "Semaphores (Binary & Counting)",
        "Condition Variables & Locks",
        "Readers‑Writers & Starvation",
        "Deadlock Analysis"
      ],
      "key_concepts": [
        "Semaphore (P/V)",
        "sem_wait / sem_post",
        "Binary semaphore as lock",
        "Counting semaphore for buffer slots",
        "Condition variable signaling",
        "Mutex for critical sections",
        "Bounded buffer implementation",
        "Producer‑Consumer synchronization",
        "Deadlock detection & prevention",
        "Starvation in readers‑writers",
        "Priority lock for fairness"
      ],
      "skills": [
        "Implement producer‑consumer with semaphores",
        "Use mutexes and condition variables for synchronization",
        "Analyze and resolve deadlock scenarios",
        "Design readers‑writers solutions with priority",
        "Simulate bounded buffer operations",
        "Debug semaphore value errors",
        "Apply Dijkstra’s semaphore concepts",
        "Write POSIX semaphore code"
      ],
      "important_terms": [
        "Semaphore",
        "Binary semaphore",
        "Counting semaphore",
        "P operation",
        "V operation",
        "sem_wait",
        "sem_post",
        "Mutex",
        "Condition variable",
        "Critical section",
        "Bounded buffer",
        "Producer",
        "Consumer",
        "Deadlock",
        "Starvation",
        "Readers‑writers",
        "Priority lock",
        "POSIX semaphores",
        "Queueing",
        "Blocking",
        "Wake",
        "Signal",
        "Lock",
        "Unlock"
      ]
    },
    {
      "deck": "OSN_L18.pdf",
      "topics": [
        "Readers–Writers Problem",
        "Dining Philosophers Problem",
        "Concurrency Bugs Overview",
        "Atomicity Violations",
        "Order Violations",
        "Deadlock Theory",
        "Deadlock Prevention Techniques",
        "Deadlock Avoidance Strategies",
        "Locking Mechanisms & Ordering",
        "Hardware Atomic Primitives"
      ],
      "key_concepts": [
        "Readers–Writers solution with priority queue and turnstile semaphore",
        "Dining Philosophers deadlock‑free ordering (odd/even strategy)",
        "Deadlock conditions: mutual exclusion, hold‑and‑wait, no preemption, circular wait",
        "Lock ordering to eliminate circular wait",
        "trylock (non‑blocking mutex acquisition)",
        "Compare‑and‑Swap for lock‑free updates",
        "Deadlock avoidance via scheduling (Banker’s algorithm)",
        "Deadlock detection with resource graphs",
        "Starvation and livelock concepts",
        "Priority common service queue for writers"
      ],
      "skills": [
        "Analyze and classify concurrency bugs (atomicity, order, deadlock)",
        "Design a readers–writers solution that prevents writer starvation",
        "Implement a dining philosophers algorithm that avoids deadlock",
        "Identify all four deadlock conditions in a given system",
        "Apply lock ordering to eliminate circular wait cycles",
        "Use trylock to implement non‑blocking synchronization",
        "Employ compare‑and‑swap for lock‑free data structures",
        "Detect deadlock cycles using resource graphs",
        "Recover from deadlock by aborting or restarting transactions",
        "Prevent starvation in concurrent systems",
        "Reason about livelock scenarios"
      ],
      "important_terms": [
        "atomicity",
        "order violation",
        "deadlock",
        "livelock",
        "starvation",
        "mutex",
        "semaphore",
        "condition variable",
        "trylock",
        "compare‑and‑swap",
        "lock ordering",
        "resource graph",
        "Banker’s algorithm",
        "mutual exclusion",
        "hold‑and‑wait",
        "no preemption",
        "circular wait",
        "priority queue",
        "turnstile semaphore",
        "readers–writers",
        "dining philosophers"
      ]
    },
    {
      "deck": "OSN_L19.pdf",
      "topics": [
        "Link Layer Overview",
        "MAC Addressing and IEEE Standards",
        "Address Resolution Protocol (ARP)",
        "Subnetting and CIDR Notation",
        "Host-to-Host Communication in LANs",
        "Encapsulation Across OSI Layers",
        "Role of the Network Layer and Default Gateway"
      ],
      "key_concepts": [
        "Encapsulation hierarchy (application to physical)",
        "48‑bit MAC address format and uniqueness",
        "ARP request/response mechanism",
        "ARP cache entries with TTL (20 min)",
        "Broadcast addressing (FF:FF:FF:FF:FF:FF)",
        "Subnet mask and CIDR (/24, /16)",
        "Default gateway usage for inter‑network traffic",
        "IP‑to‑MAC mapping resolution",
        "Link‑layer flow control and error detection",
        "Hop‑to‑hop communication via switches",
        "Switch vs router responsibilities",
        "ARP cache update on receipt of ARP reply",
        "ARP request packet format (sender IP/MAC, target IP)",
        "ARP reply packet format (sender IP/MAC)",
        "IEEE assignment of MAC address blocks",
        "TTL expiration and cache eviction",
        "Private vs public IP addressing",
        "Broadcast domain definition",
        "Layer‑specific addressing (MAC vs IP)",
        "Physical link representation in frames"
      ],
      "skills": [
        "Analyze ARP cache behavior and TTL handling",
        "Determine the MAC address for a given IP using ARP",
        "Compute subnet masks and CIDR ranges for network design",
        "Identify and configure the default gateway for routing",
        "Explain encapsulation across OSI layers",
        "Troubleshoot link‑layer communication failures",
        "Interpret ARP request and reply packets",
        "Configure ARP cache entries manually",
        "Design a LAN addressing scheme with unique MACs",
        "Differentiate switch and router roles in a network",
        "Evaluate the impact of broadcast traffic on performance",
        "Understand flow control and error detection mechanisms at the link layer"
      ],
      "important_terms": [
        "MAC address",
        "ARP",
        "ARP cache",
        "TTL",
        "broadcast",
        "subnet mask",
        "CIDR",
        "default gateway",
        "IP address",
        "host",
        "switch",
        "router",
        "frame",
        "packet",
        "link layer",
        "network layer",
        "physical layer",
        "encapsulation",
        "hop‑to‑hop",
        "IEEE",
        "48‑bit",
        "12 hex digits",
        "FF:FF:FF:FF:FF:FF",
        "255.255.255.0",
        "255.255.0.0",
        "/24",
        "/16"
      ]
    },
    {
      "deck": "OSN_L20.pdf",
      "topics": [
        "Network Layer Fundamentals",
        "Addressing and Subnetting",
        "Link Layer ARP and MAC",
        "Routing and Forwarding Mechanisms",
        "Routing Protocols (OSPF, BGP)",
        "IP Address Management (DHCP, Static)",
        "Network Address Translation (NAT)",
        "Control Plane vs Data Plane",
        "Autonomous Systems and Internet Scalability",
        "IPv4 vs IPv6 Addressing"
      ],
      "key_concepts": [
        "Encapsulation hierarchy (Application→Transport→Network→Link→Physical)",
        "CIDR and subnet mask calculation",
        "ARP request/response and ARP table population",
        "Routing table composition (connected, static, dynamic)",
        "Static vs Dynamic routing entries",
        "OSPF link‑state algorithm (Dijkstra)",
        "BGP path‑vector and AS‑path selection",
        "DHCP discover/offer/ack flow",
        "NAT translation table and overload (PAT)",
        "IP address allocation via DHCP and static config",
        "IPv4 address exhaustion and IPv6 expansion",
        "Forwarding plane processing per router",
        "Control plane routing protocol exchange",
        "Gateway router role in inter‑AS routing",
        "NAT types: static, dynamic, overload"
      ],
      "skills": [
        "Configure static routes on routers",
        "Analyze and interpret routing tables",
        "Explain ARP operation in a LAN",
        "Design subnetting schemes using CIDR",
        "Implement a basic DHCP client/server",
        "Describe NAT translation and PAT",
        "Compare OSPF and BGP routing principles",
        "Interpret SDN control plane concepts",
        "Compute IP ranges for given CIDR",
        "Explain IPv6 address structure and benefits"
      ],
      "important_terms": [
        "IP",
        "TCP",
        "UDP",
        "ARP",
        "DHCP",
        "NAT",
        "PAT",
        "OSPF",
        "BGP",
        "CIDR",
        "subnet mask",
        "routing table",
        "forwarding table",
        "static route",
        "dynamic route",
        "autonomous system",
        "AS",
        "SDN",
        "link‑state",
        "path‑vector",
        "IPv4",
        "IPv6",
        "gateway",
        "interface",
        "datagram",
        "segment",
        "encapsulation"
      ]
    },
    {
      "deck": "OSN_L21.pdf",
      "topics": [
        "Persistence and storage hierarchy",
        "Hard disk fundamentals",
        "Disk I/O path and DMA",
        "Disk performance metrics",
        "Disk scheduling algorithms",
        "Disk caching and write policies",
        "RAID concepts",
        "OS role in I/O management"
      ],
      "key_concepts": [
        "Volatile vs non‑volatile memory",
        "File system interaction with device drivers",
        "Disk geometry: sectors, tracks, platters",
        "Rotational latency, seek time, transfer time",
        "Atomic 512‑byte writes",
        "Disk cache buffer and skew",
        "Write‑through vs write‑back policies",
        "SSTF (Shortest Seek Time First)",
        "SCAN / C‑SCAN / F‑SCAN scheduling",
        "Random vs sequential workload analysis",
        "RAID basic architecture",
        "DMA transfer mechanism"
      ],
      "skills": [
        "Analyze disk I/O latency components",
        "Compare performance of different disk drives",
        "Explain effect of rotational delay and seek time",
        "Evaluate disk scheduling algorithms",
        "Calculate I/O time for given workloads",
        "Understand write‑through vs write‑back caching",
        "Discuss RAID benefits and trade‑offs",
        "Interpret disk performance metrics",
        "Model disk I/O path (CPU→OS→FS→DMA→disk)",
        "Identify causes of torn writes"
      ],
      "important_terms": [
        "RAM",
        "HDD",
        "SSD",
        "DMA",
        "SCSI",
        "SATA",
        "rotational latency",
        "seek time",
        "transfer time",
        "atomic write",
        "write‑through",
        "write‑back",
        "cache buffer",
        "SSTF",
        "SCAN",
        "C‑SCAN",
        "F‑SCAN",
        "RAID",
        "disk skew",
        "platter",
        "sector",
        "block",
        "file system",
        "device driver",
        "I/O scheduler"
      ]
    },
    {
      "deck": "OSN_L22.pdf",
      "topics": [
        "Disk I/O fundamentals",
        "RAID architecture and evaluation",
        "RAID‑0 striping",
        "RAID‑1 mirroring",
        "RAID‑4 parity",
        "RAID‑5 rotating parity",
        "Performance analysis of RAID",
        "Reliability and fault tolerance",
        "Small‑write problem and solutions",
        "Comparison of RAID levels"
      ],
      "key_concepts": [
        "Disk seek, rotational latency, and transfer time",
        "Block, sector, and track organization",
        "RAID striping and chunk size impact",
        "RAID mirroring read/write behavior",
        "Parity calculation using XOR",
        "Additive vs subtractive parity update",
        "Small‑write bottleneck in RAID‑4",
        "Rotating parity to eliminate bottleneck",
        "Capacity, reliability, and performance evaluation axes",
        "Steady‑state throughput for sequential and random I/O",
        "Single‑request latency in RAID",
        "Disk controller DMA operations",
        "RAID controller firmware and DRAM buffer",
        "Non‑volatile memory for parity storage",
        "Fault model: total disk failure",
        "RAID‑5 random write throughput formula",
        "Parity disk as bottleneck in RAID‑4",
        "Parallelism in RAID‑1 writes",
        "Sequential read/write bandwidth scaling",
        "Random read/write bandwidth scaling"
      ],
      "skills": [
        "Analyze RAID performance under sequential and random workloads",
        "Compute capacity, reliability, and throughput for different RAID levels",
        "Evaluate trade‑offs between striping and mirroring",
        "Design parity schemes using XOR for fault tolerance",
        "Optimize small‑write performance in RAID‑4",
        "Interpret disk I/O timing equations",
        "Compare RAID‑0, RAID‑1, RAID‑4, and RAID‑5 characteristics",
        "Explain RAID controller architecture and firmware roles",
        "Assess impact of chunk size on RAID performance",
        "Identify bottlenecks in RAID‑4 and RAID‑5",
        "Apply XOR for parity calculation in practice",
        "Model RAID‑5 random write throughput"
      ],
      "important_terms": [
        "RAID",
        "RAID‑0",
        "RAID‑1",
        "RAID‑4",
        "RAID‑5",
        "striping",
        "mirroring",
        "parity",
        "XOR",
        "additive parity",
        "subtractive parity",
        "small‑write problem",
        "rotating parity",
        "disk seek",
        "rotational latency",
        "transfer time",
        "block",
        "sector",
        "track",
        "DMA",
        "disk controller",
        "firmware",
        "DRAM buffer",
        "non‑volatile memory",
        "fault tolerance",
        "throughput",
        "latency",
        "sequential I/O",
        "random I/O",
        "steady‑state throughput",
        "capacity",
        "reliability"
      ]
    },
    {
      "deck": "OSN_L23.pdf",
      "topics": [
        "Persistence Devices and Interfaces",
        "File System Abstractions",
        "File System System Calls",
        "Metadata and Inode Management",
        "Directory Structure and Linking",
        "Mounting and File System Organization",
        "Simple File System Design",
        "Buffering and Synchronization"
      ],
      "key_concepts": [
        "File system abstraction of storage",
        "Inode structure and metadata storage",
        "Directory entries and hierarchical tree",
        "File creation/open/read/write APIs",
        "Random access via lseek",
        "Durability with fsync",
        "Hard link semantics and link count",
        "Soft (symbolic) link behavior",
        "Superblock layout and mount initialization",
        "Bitmap allocation for free blocks",
        "Buffer cache and write-back policy",
        "Sequential vs random file access",
        "File descriptor semantics",
        "File permission flags (O_CREAT, O_WRONLY, O_TRUNC, O_RDONLY)",
        "Seek constants (SEEK_SET, SEEK_CUR, SEEK_END)",
        "Disk block organization",
        "Mounting a file system into the namespace",
        "Directory entries '.' and '..'",
        "Linking limitations across file systems"
      ],
      "skills": [
        "Implement file open/read/write logic in a kernel module",
        "Design and manage an inode table and bitmap allocation",
        "Create hard and soft links using system calls",
        "Use lseek for random file access",
        "Apply fsync to guarantee persistence",
        "Simulate a simple file system layout (superblock, inode table, data blocks)",
        "Analyze directory tree structure and path resolution",
        "Understand and manipulate file descriptor tables",
        "Implement buffer cache write-back strategy",
        "Mount and unmount file systems programmatically"
      ],
      "important_terms": [
        "inode",
        "i-node number",
        "superblock",
        "bitmap",
        "lseek",
        "fsync",
        "hard link",
        "soft link",
        "mount",
        "directory tree",
        "file descriptor",
        "O_CREAT",
        "O_WRONLY",
        "O_TRUNC",
        "O_RDONLY",
        "SEEK_SET",
        "SEEK_CUR",
        "SEEK_END",
        "block",
        "data block",
        "metadata",
        "file system interface",
        "buffer cache",
        "file permissions"
      ]
    },
    {
      "deck": "OSN_L24.pdf",
      "topics": [
        "File System Architecture",
        "Inode and Superblock Design",
        "Direct and Indirect Block Pointers",
        "Directory Structure and Pathname Resolution",
        "Free Space Management Techniques",
        "File Access Semantics (open/read/write)",
        "Caching and Buffering Strategies",
        "Performance Tradeoffs and Durability"
      ],
      "key_concepts": [
        "Superblock metadata",
        "Inode structure and layout",
        "Direct block pointers",
        "Single indirect pointers",
        "Double indirect pointers",
        "Triple indirect pointers",
        "Directory entry format",
        "Open file table (global and per-process)",
        "Bitmap-based free space allocation",
        "LRU cache eviction",
        "Write buffering and delayed writes",
        "fsync and immediate persistence",
        "Block size and allocation granularity",
        "File descriptor abstraction",
        "DMA and disk controller interaction"
      ],
      "skills": [
        "Compute inode offset from inode number",
        "Traverse a pathname to locate a file",
        "Allocate inodes and data blocks using bitmaps",
        "Design a simple directory entry lookup",
        "Implement a basic open/read/write sequence",
        "Implement a bitmap-based free space manager",
        "Design a cache eviction policy (LRU)",
        "Analyze I/O overhead for file operations",
        "Balance durability and performance using fsync",
        "Simulate file system metadata updates"
      ],
      "important_terms": [
        "Inode",
        "Superblock",
        "Direct pointer",
        "Indirect pointer",
        "Double indirect pointer",
        "Triple indirect pointer",
        "Directory entry",
        "Open file table",
        "Bitmap",
        "LRU",
        "Write buffering",
        "fsync",
        "DMA",
        "Block size",
        "File descriptor"
      ]
    },
    {
      "deck": "OSN_L25_revision.pdf",
      "topics": [
        "Process Virtualization & Scheduling",
        "Operating System Role in Networking",
        "Network Layering: OSI & TCP/IP Models",
        "Transport Layer Protocols (TCP vs UDP)",
        "Memory Management (Segmentation & Paging)",
        "Concurrency and Synchronization",
        "Routing, NAT, and Address Resolution (ARP, DHCP)",
        "Storage and File Systems (RAID, VSFS)"
      ],
      "key_concepts": [
        "Process Control Block (PCB)",
        "State transition diagram (running, ready, blocked)",
        "Context switch",
        "System calls as network primitives",
        "OSI model layers and encapsulation",
        "TCP three-way handshake",
        "UDP reliability trade-offs",
        "Paging and TLB",
        "Segmentation and external fragmentation",
        "Semaphores and mutexes",
        "Producer-consumer problem",
        "ARP cache and broadcast queries",
        "DHCP lease acquisition over UDP",
        "NAT translation table and overload",
        "RAID levels and redundancy"
      ],
      "skills": [
        "Analyze process state transitions and identify deadlock scenarios",
        "Implement a simple context switch simulator",
        "Design and explain a TCP three-way handshake",
        "Simulate paging and TLB behavior",
        "Implement semaphore-based producer-consumer solution",
        "Build a basic ARP cache and resolve IP-to-MAC mapping",
        "Configure DHCP client to obtain IP address",
        "Model NAT translation and compute mapping entries",
        "Create a simple file system with inodes and path traversal",
        "Evaluate RAID configurations for fault tolerance"
      ],
      "important_terms": [
        "Process Control Block (PCB)",
        "Context Switch",
        "System Call",
        "OSI Model",
        "TCP",
        "UDP",
        "3-way Handshake",
        "Segmentation",
        "Paging",
        "TLB",
        "Semaphore",
        "Mutex",
        "Producer-Consumer",
        "ARP",
        "DHCP",
        "NAT",
        "IP Address",
        "MAC Address",
        "RAID",
        "Inode"
      ]
    }
  ],
  "learning_objectives": [
    "CO-1: By the end of this course, students will be able to design and implement three CPU scheduling algorithms (FCFS, Round Robin, Multi‑Level Feedback Queue) in a simulated environment to demonstrate accurate process state transitions and evaluate performance metrics such as turnaround and response time.",
    "CO-2: By the end of this course, students will be able to construct a virtual memory manager simulation that translates virtual addresses to physical addresses using multi‑level page tables and a Translation Lookaside Buffer (TLB), and evaluate hit rates to demonstrate mastery of address translation and memory protection.",
    "CO-3: By the end of this course, students will be able to design and implement a simplified file system module that manages inodes, directory trees, and block allocation via bitmaps, and perform file operations (create, read, write, delete) to demonstrate file system design and persistence mechanisms.",
    "CO-4: By the end of this course, students will be able to develop a TCP client and server application using the socket API, perform a three‑way handshake, and analyze packet headers to demonstrate understanding of transport layer protocols and connection establishment.",
    "CO-5: By the end of this course, students will be able to implement a producer‑consumer problem using POSIX semaphores and mutexes, detect and resolve potential deadlocks, and evaluate throughput to demonstrate concurrency control and synchronization primitives.",
    "CO-6: By the end of this course, students will be able to evaluate disk I/O scheduling algorithms (FCFS, SSTF, SCAN) and RAID configurations (RAID‑0, RAID‑1, RAID‑5) through simulation and performance metrics to demonstrate knowledge of storage hierarchy and fault tolerance.",
    "CO-7: By the end of this course, students will be able to analyze ARP, DHCP, and DNS protocols, construct an ARP cache and DNS resolver, and demonstrate correct IP‑to‑MAC resolution and name resolution in a simulated network to demonstrate networking fundamentals and protocol interactions."
  ]
}